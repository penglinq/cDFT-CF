Currently Loaded Modulefiles:
 1) gmp/6.2.1-gcc-13.2.0-lcnhyse <aL>             
 2) mpfr/4.2.0-gcc-13.2.0-yy2fkq5 <aL>            
 3) mpc/1.3.1-gcc-13.2.0-5kgoftq <aL>             
 4) zlib-ng/2.1.3-gcc-13.2.0-jetnfwa <aL>         
 5) zstd/1.5.5-gcc-13.2.0-t2lua3l <aL>            
 6) gcc/13.2.0-gcc-13.2.0-w55nxkl                 
 7) cmake/3.20.2-gcc-13.2.0-rp74vpv               
 8) libfabric/1.18.1-gcc-13.2.0-bijxar4 <aL>      
 9) numactl/2.0.14-gcc-13.2.0-etkf74e <aL>        
10) openssh/8.7p1-gcc-13.2.0-g55xmkx <aL>         
11) slurm/22.05.6-gcc-13.2.0-tchsn6y <aL>         
12) openmpi/4.1.5-gcc-13.2.0-24q3ap2              
13) libpciaccess/0.17-gcc-13.2.0-r2cijnn <aL>     
14) libiconv/1.17-gcc-13.2.0-ntov4te <aL>         
15) xz/5.4.1-gcc-13.2.0-4xkm5xo <aL>              
16) libxml2/2.10.3-gcc-13.2.0-fr6jcjz <aL>        
17) ncurses/6.4-gcc-13.2.0-4o2yj6n <aL>           
18) hwloc/2.9.1-gcc-13.2.0-gzvfolk <aL>           
19) intel-tbb/2021.9.0-gcc-13.2.0-6nwk3ml <aL>    
20) intel-oneapi-mkl/2023.2.0-gcc-13.2.0-ohvyk7g  

Key:
<module-tag>  <aL>=auto-loaded  
/central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF
Thu Apr 17 13:20:27 PDT 2025
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
hpc-80-16.cm.cluster
--------------------------------------------------------------------------
WARNING: There was an error initializing an OpenFabrics device.

  Local host:   hpc-80-16
  Local device: mlx5_0
--------------------------------------------------------------------------
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:20:31 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      #INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      '''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   #INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   [INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   [CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   [CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

CPU time:         1.14
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_59/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]

numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
number of NR pGTOs = 449
number of NR cGTOs = 198
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
ecp = {}
CPU time:         1.16
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.17
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.15
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

N_elec (88, 83), N_ao 198
number of NR pGTOs = 449
N_elec (88, 83), N_ao 198
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
ecp = {}
CPU time:         1.16
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0
number of NR pGTOs = 449
number of NR cGTOs = 198
number of NR pGTOs = 449

basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
number of NR cGTOs = 198
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6CPU time:         1.16
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.16
nuclear repulsion = 1868.38919656687
number of shells = 84
N_elec (88, 83), N_ao 198
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.16
System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
N_elec (88, 83), N_ao 198
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

nuclear repulsion = 1868.38919656687
number of shells = 84
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.15
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.16
N_elec (88, 83), N_ao 198
number of NR cGTOs = 198
nuclear repulsion = 1868.38919656687
CPU time:         1.17
System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
System: uname_result(system='Linux', node='hpc-80-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.17
N_elec (88, 83), N_ao 198
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:20:33 2025
PySCF version 2.5.0
number of shells = 84
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
[INPUT] num. electrons = 171
[INPUT] charge = -3
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

number of NR pGTOs = 449
number of NR cGTOs = 198
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.16
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] num. atoms = 7
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0

[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.16
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.18
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.17
N_elec (88, 83), N_ao 198
**** MO energy ****
MO #1   energy= -1986.50517035044  occ= 1
MO #2   energy= -1986.50505773187  occ= 1
MO #3   energy= -335.744316806285  occ= 1
MO #4   energy= -335.743855395154  occ= 1
MO #5   energy= -318.560582571652  occ= 1
MO #6   energy= -318.56032061849   occ= 1
MO #7   energy= -288.739604261381  occ= 1
MO #8   energy= -288.739229860674  occ= 1
MO #9   energy= -288.731461702379  occ= 1
MO #10  energy= -288.731338027874  occ= 1
MO #11  energy= -105.084016676148  occ= 1
MO #12  energy= -105.083996796298  occ= 1
MO #13  energy= -105.083876848129  occ= 1
MO #14  energy= -105.083856948781  occ= 1
MO #15  energy= -105.081713115512  occ= 1
MO #16  energy= -105.081709448205  occ= 1
MO #17  energy= -105.081616703636  occ= 1
MO #18  energy= -105.081595091285  occ= 1
MO #19  energy= -105.081585524117  occ= 1
MO #20  energy= -105.081581858191  occ= 1
MO #21  energy= -105.08148913292   occ= 1
MO #22  energy= -105.081467501696  occ= 1
MO #23  energy= -77.0766563172536  occ= 1
MO #24  energy= -76.9571302630635  occ= 1
MO #25  energy= -69.5781283478794  occ= 1
MO #26  energy= -69.5595777208725  occ= 1
MO #27  energy= -63.2148879815718  occ= 1
MO #28  energy= -63.205678251226   occ= 1
MO #29  energy= -63.1305161262     occ= 1
MO #30  energy= -63.0451549931483  occ= 1
MO #31  energy= -50.7715247339008  occ= 1
MO #32  energy= -50.7676266846903  occ= 1
MO #33  energy= -50.7598886207213  occ= 1
MO #34  energy= -50.7374491941923  occ= 1
MO #35  energy= -49.195902204222   occ= 1
MO #36  energy= -49.1795664256039  occ= 1
MO #37  energy= -49.1678188820211  occ= 1
MO #38  energy= -49.0955308237575  occ= 1
MO #39  energy= -49.0499296031014  occ= 1
MO #40  energy= -48.9959610593918  occ= 1
MO #41  energy= -16.5559816039361  occ= 1
MO #42  energy= -16.2410520097331  occ= 1
MO #43  energy= -13.4591094477825  occ= 1
MO #44  energy= -13.4139945456977  occ= 1
MO #45  energy= -12.0551999136694  occ= 1
MO #46  energy= -12.015325856847   occ= 1
MO #47  energy= -11.8190571307945  occ= 1
MO #48  energy= -11.6602126035052  occ= 1
MO #49  energy= -10.4910982985124  occ= 1
MO #50  energy= -10.4910786770623  occ= 1
MO #51  energy= -10.4909457586566  occ= 1
MO #52  energy= -10.4909261173051  occ= 1
MO #53  energy= -10.4887239600075  occ= 1
MO #54  energy= -10.4887221629705  occ= 1
MO #55  energy= -10.4886285772427  occ= 1
MO #56  energy= -10.4886072104397  occ= 1
MO #57  energy= -10.4885847198744  occ= 1
MO #58  energy= -10.4885829256431  occ= 1
MO #59  energy= -10.4884893975222  occ= 1
MO #60  energy= -10.488468011373   occ= 1
MO #61  energy= -7.94823104672133  occ= 1
MO #62  energy= -7.94821138452165  occ= 1
MO #63  energy= -7.94813333296625  occ= 1
MO #64  energy= -7.94811365991028  occ= 1
MO #65  energy= -7.94589832937767  occ= 1
MO #66  energy= -7.94589653300926  occ= 1
MO #67  energy= -7.94580279017618  occ= 1
MO #68  energy= -7.94578138677719  occ= 1
MO #69  energy= -7.94575801325217  occ= 1
MO #70  energy= -7.9457562144878   occ= 1
MO #71  energy= -7.94566247980471  occ= 1
MO #72  energy= -7.9456410543808   occ= 1
MO #73  energy= -7.88037714692213  occ= 1
MO #74  energy= -7.88035739381663  occ= 1
MO #75  energy= -7.88010338795193  occ= 1
MO #76  energy= -7.88008359651989  occ= 1
MO #77  energy= -7.87945610522767  occ= 1
MO #78  energy= -7.87943585930786  occ= 1
MO #79  energy= -7.87933976015407  occ= 1
MO #80  energy= -7.87931949049381  occ= 1
MO #81  energy= -7.87799993727496  occ= 1
MO #82  energy= -7.87799727759365  occ= 1
MO #83  energy= -7.87790329256549  occ= 1
MO #84  energy= -7.8778818135949   occ= 1
MO #85  energy= -7.87773584088879  occ= 1
MO #86  energy= -7.87773317097667  occ= 1
MO #87  energy= -7.8776392311472   occ= 1
MO #88  energy= -7.87761770741268  occ= 1
MO #89  energy= -7.87706026965016  occ= 1
MO #90  energy= -7.87705508779921  occ= 1
MO #91  energy= -7.87704279068159  occ= 1
MO #92  energy= -7.87703761829606  occ= 1
MO #93  energy= -7.87696162319446  occ= 1
MO #94  energy= -7.87694763576947  occ= 1
MO #95  energy= -7.87693965143604  occ= 1
MO #96  energy= -7.87692564987675  occ= 1
MO #97  energy= -7.14118289691839  occ= 1
MO #98  energy= -7.13994058359808  occ= 1
MO #99  energy= -7.11073633079296  occ= 1
MO #100 energy= -7.04895150751452  occ= 1
MO #101 energy= -6.81784666948482  occ= 1
MO #102 energy= -6.77079788498953  occ= 1
MO #103 energy= -6.6101537979355   occ= 1
MO #104 energy= -6.39862556331222  occ= 1
MO #105 energy= -6.33390417444801  occ= 1
MO #106 energy= -6.2374404427991   occ= 1
MO #107 energy= -2.38420637224265  occ= 1
MO #108 energy= -2.26752033353482  occ= 1
MO #109 energy= -1.41521852816696  occ= 1
MO #110 energy= -1.41180998100809  occ= 1
MO #111 energy= -1.22078518030147  occ= 1
MO #112 energy= -1.21514421725562  occ= 1
MO #113 energy= -1.17891985510663  occ= 1
MO #114 energy= -1.13391893369989  occ= 1
MO #115 energy= -0.953230502812954 occ= 1
MO #116 energy= -0.952648895746651 occ= 1
MO #117 energy= -0.944950745829728 occ= 1
MO #118 energy= -0.944068161332619 occ= 1
MO #119 energy= -0.943354634242773 occ= 1
MO #120 energy= -0.942456311664919 occ= 1
MO #121 energy= -0.942244553639201 occ= 1
MO #122 energy= -0.941737544266172 occ= 1
MO #123 energy= -0.93737494613759  occ= 1
MO #124 energy= -0.936559042878515 occ= 1
MO #125 energy= -0.936337531223335 occ= 1
MO #126 energy= -0.932886407913413 occ= 1
MO #127 energy= -0.858936881222556 occ= 1
MO #128 energy= -0.85439512600316  occ= 1
MO #129 energy= -0.837622285563841 occ= 1
MO #130 energy= -0.815246344211015 occ= 1
MO #131 energy= -0.780613914581336 occ= 1
MO #132 energy= -0.777584760940757 occ= 1
MO #133 energy= -0.727967473208227 occ= 1
MO #134 energy= -0.6316435510234   occ= 1
MO #135 energy= -0.617070774295295 occ= 1
MO #136 energy= -0.406343232407302 occ= 1
MO #137 energy= -0.405148002132986 occ= 1
MO #138 energy= -0.383401261851745 occ= 1
MO #139 energy= -0.382174272068729 occ= 1
MO #140 energy= -0.380193818921113 occ= 1
MO #141 energy= -0.379884596426531 occ= 1
MO #142 energy= -0.372444470784665 occ= 1
MO #143 energy= -0.3721039308657   occ= 1
MO #144 energy= -0.371327479092808 occ= 1
MO #145 energy= -0.371274147848028 occ= 1
MO #146 energy= -0.370510897657659 occ= 1
MO #147 energy= -0.370357753396381 occ= 1
MO #148 energy= -0.368672198193487 occ= 1
MO #149 energy= -0.368392662644194 occ= 1
MO #150 energy= -0.368257062554271 occ= 1
MO #151 energy= -0.368186400790232 occ= 1
MO #152 energy= -0.367619157165834 occ= 1
MO #153 energy= -0.366140101855379 occ= 1
MO #154 energy= -0.343366632680639 occ= 1
MO #155 energy= -0.342699071003613 occ= 1
MO #156 energy= -0.341274821237033 occ= 1
MO #157 energy= -0.341138207037918 occ= 1
MO #158 energy= -0.340606200545222 occ= 1
MO #159 energy= -0.340342667965752 occ= 1
MO #160 energy= -0.338139505680557 occ= 1
MO #161 energy= -0.338004292212424 occ= 1
MO #162 energy= -0.335437131858989 occ= 1
MO #163 energy= -0.335033870418508 occ= 1
MO #164 energy= -0.334251057277979 occ= 1
MO #165 energy= -0.333698873265388 occ= 1
MO #166 energy= -0.327144674674046 occ= 1
MO #167 energy= -0.326908712188525 occ= 1
MO #168 energy= -0.324672087697349 occ= 1
MO #169 energy= -0.324186759375241 occ= 1
MO #170 energy= -0.323733696095578 occ= 1
MO #171 energy= -0.32344354712923  occ= 1
MO #172 energy= 0.122832803582642  occ= 0
MO #173 energy= 0.122883101263087  occ= 0
MO #174 energy= 0.122992995519479  occ= 0
MO #175 energy= 0.123068956389217  occ= 0
MO #176 energy= 0.12317618233811   occ= 0
MO #177 energy= 0.123273417974223  occ= 0
MO #178 energy= 0.12956869698434   occ= 0
MO #179 energy= 0.129572453642185  occ= 0
MO #180 energy= 0.129796207454404  occ= 0
MO #181 energy= 0.12980240611099   occ= 0
MO #182 energy= 0.129921926669511  occ= 0
MO #183 energy= 0.129923454702582  occ= 0
MO #184 energy= 0.133451381330036  occ= 0
MO #185 energy= 0.133556349846642  occ= 0
MO #186 energy= 0.153446860034882  occ= 0
MO #187 energy= 0.153838753685689  occ= 0
MO #188 energy= 0.153944281358634  occ= 0
MO #189 energy= 0.154131048804365  occ= 0
MO #190 energy= 0.205824299066087  occ= 0
MO #191 energy= 0.209292292361354  occ= 0
MO #192 energy= 0.215689651684549  occ= 0
MO #193 energy= 0.222926472217651  occ= 0
MO #194 energy= 0.2321566196403    occ= 0
MO #195 energy= 0.23697959782964   occ= 0
MO #196 energy= 0.287905665302972  occ= 0
MO #197 energy= 0.296634926145067  occ= 0
MO #198 energy= 0.296886011306138  occ= 0
MO #199 energy= 0.298349432780224  occ= 0
MO #200 energy= 0.298484517327048  occ= 0
MO #201 energy= 0.298882500256755  occ= 0
MO #202 energy= 0.298953521423842  occ= 0
MO #203 energy= 0.304079118664144  occ= 0
MO #204 energy= 0.31036099055701   occ= 0
MO #205 energy= 0.312338867995835  occ= 0
MO #206 energy= 0.321138229810051  occ= 0
MO #207 energy= 0.323419290104316  occ= 0
MO #208 energy= 0.337143119750857  occ= 0
MO #209 energy= 0.337555709496776  occ= 0
MO #210 energy= 0.338413589594399  occ= 0
MO #211 energy= 0.33916112157596   occ= 0
MO #212 energy= 0.340886689745898  occ= 0
MO #213 energy= 0.341460452361936  occ= 0
MO #214 energy= 0.343092578151556  occ= 0
MO #215 energy= 0.344527037224155  occ= 0
MO #216 energy= 0.348711308160453  occ= 0
MO #217 energy= 0.351825874840762  occ= 0
MO #218 energy= 0.404250037243178  occ= 0
MO #219 energy= 0.411539226555026  occ= 0
MO #220 energy= 0.437750657838555  occ= 0
MO #221 energy= 0.443237691553152  occ= 0
MO #222 energy= 0.475411878046137  occ= 0
MO #223 energy= 0.475899850722145  occ= 0
MO #224 energy= 0.483913392955771  occ= 0
MO #225 energy= 0.492075107186736  occ= 0
MO #226 energy= 0.495957039320529  occ= 0
MO #227 energy= 0.499388051801579  occ= 0
MO #228 energy= 0.510944384742784  occ= 0
MO #229 energy= 0.516439508171354  occ= 0
MO #230 energy= 0.547555372766626  occ= 0
MO #231 energy= 0.549394164961002  occ= 0
MO #232 energy= 0.579348669051236  occ= 0
MO #233 energy= 0.605923251073524  occ= 0
MO #234 energy= 0.60783244504617   occ= 0
MO #235 energy= 0.608075528715036  occ= 0
MO #236 energy= 0.611955756321828  occ= 0
MO #237 energy= 0.62157543775924   occ= 0
MO #238 energy= 0.627915099173095  occ= 0
MO #239 energy= 0.628932323603572  occ= 0
MO #240 energy= 0.631435635363082  occ= 0
MO #241 energy= 0.634948835160784  occ= 0
MO #242 energy= 0.665414802717776  occ= 0
MO #243 energy= 0.672632131969464  occ= 0
MO #244 energy= 0.688006740190361  occ= 0
MO #245 energy= 0.742009924648218  occ= 0
MO #246 energy= 0.74607863887523   occ= 0
MO #247 energy= 0.748479066580355  occ= 0
MO #248 energy= 0.750173789702263  occ= 0
MO #249 energy= 0.77078259896819   occ= 0
MO #250 energy= 0.771041533501811  occ= 0
MO #251 energy= 0.773393823979886  occ= 0
MO #252 energy= 0.777157022315157  occ= 0
MO #253 energy= 0.777254398497055  occ= 0
MO #254 energy= 0.777608586520376  occ= 0
MO #255 energy= 0.77767278432273   occ= 0
MO #256 energy= 0.777740570507428  occ= 0
MO #257 energy= 0.780536217059364  occ= 0
MO #258 energy= 0.78058607875269   occ= 0
MO #259 energy= 0.782907908866694  occ= 0
MO #260 energy= 0.792958669204328  occ= 0
MO #261 energy= 0.801369286184512  occ= 0
MO #262 energy= 0.801483743373399  occ= 0
MO #263 energy= 0.804929927483343  occ= 0
MO #264 energy= 0.805378487537759  occ= 0
MO #265 energy= 0.805625300074957  occ= 0
MO #266 energy= 0.806156708105563  occ= 0
MO #267 energy= 0.806485918434973  occ= 0
MO #268 energy= 0.81009062935079   occ= 0
MO #269 energy= 0.867178756942425  occ= 0
MO #270 energy= 0.86727540870276   occ= 0
MO #271 energy= 0.869820940048608  occ= 0
MO #272 energy= 0.87000914638245   occ= 0
MO #273 energy= 0.870499206716508  occ= 0
MO #274 energy= 0.870607802814908  occ= 0
MO #275 energy= 0.933009985226555  occ= 0
MO #276 energy= 0.933909316702895  occ= 0
MO #277 energy= 0.934099697151293  occ= 0
MO #278 energy= 0.934192782122591  occ= 0
MO #279 energy= 0.937660689524229  occ= 0
MO #280 energy= 0.938100495770105  occ= 0
MO #281 energy= 1.01789059361819   occ= 0
MO #282 energy= 1.01872487329189   occ= 0
MO #283 energy= 1.02009734462559   occ= 0
MO #284 energy= 1.02115082597753   occ= 0
MO #285 energy= 1.02392087919059   occ= 0
MO #286 energy= 1.02534683536185   occ= 0
MO #287 energy= 1.03026124876427   occ= 0
MO #288 energy= 1.04192725691264   occ= 0
MO #289 energy= 1.04214496345764   occ= 0
MO #290 energy= 1.04582103467945   occ= 0
MO #291 energy= 1.09192552633665   occ= 0
MO #292 energy= 1.09200774727794   occ= 0
MO #293 energy= 1.09432635532907   occ= 0
MO #294 energy= 1.09448655909279   occ= 0
MO #295 energy= 1.09477313094686   occ= 0
MO #296 energy= 1.09525461576143   occ= 0
MO #297 energy= 1.10634746244951   occ= 0
MO #298 energy= 1.11365772144126   occ= 0
MO #299 energy= 1.12192056558562   occ= 0
MO #300 energy= 1.12547301469161   occ= 0
MO #301 energy= 1.32562271214017   occ= 0
MO #302 energy= 1.33046571725669   occ= 0
MO #303 energy= 1.37049074869486   occ= 0
MO #304 energy= 1.38326586725004   occ= 0
MO #305 energy= 1.53165007150351   occ= 0
MO #306 energy= 1.53710885451042   occ= 0
MO #307 energy= 1.55584709045759   occ= 0
MO #308 energy= 1.58927174808233   occ= 0
MO #309 energy= 1.59364455588761   occ= 0
MO #310 energy= 1.60577991810811   occ= 0
MO #311 energy= 1.60734378680983   occ= 0
MO #312 energy= 1.61316664189758   occ= 0
MO #313 energy= 1.61715949680746   occ= 0
MO #314 energy= 1.62094765532046   occ= 0
MO #315 energy= 1.62817128784308   occ= 0
MO #316 energy= 1.69126396982409   occ= 0
MO #317 energy= 1.70748766431183   occ= 0
MO #318 energy= 1.71595493665367   occ= 0
MO #319 energy= 1.85670077466284   occ= 0
MO #320 energy= 1.86116545210431   occ= 0
MO #321 energy= 1.88160618658731   occ= 0
MO #322 energy= 1.92059620593453   occ= 0
MO #323 energy= 1.9221082846684    occ= 0
MO #324 energy= 1.93511306904753   occ= 0
MO #325 energy= 2.6493314358882    occ= 0
MO #326 energy= 2.67018997337362   occ= 0
MO #327 energy= 2.67890964724751   occ= 0
MO #328 energy= 2.70147122395016   occ= 0
MO #329 energy= 2.74605359922391   occ= 0
MO #330 energy= 2.76365993997882   occ= 0
MO #331 energy= 2.82386729935965   occ= 0
MO #332 energy= 2.8561897512143    occ= 0
MO #333 energy= 2.89534051590386   occ= 0
MO #334 energy= 2.91803426983976   occ= 0
MO #335 energy= 4.40999120890812   occ= 0
MO #336 energy= 4.4657261427497    occ= 0
MO #337 energy= 5.73124260069593   occ= 0
MO #338 energy= 5.74326613868557   occ= 0
MO #339 energy= 6.2434233739344    occ= 0
MO #340 energy= 6.25328555479234   occ= 0
MO #341 energy= 6.28315464044898   occ= 0
MO #342 energy= 6.3408741829683    occ= 0
MO #343 energy= 11.402976779249    occ= 0
MO #344 energy= 11.4369579404884   occ= 0
MO #345 energy= 11.4470436893543   occ= 0
MO #346 energy= 11.47530923123     occ= 0
MO #347 energy= 11.7287246860474   occ= 0
MO #348 energy= 11.7689818780445   occ= 0
MO #349 energy= 11.7722531046614   occ= 0
MO #350 energy= 11.8221366248137   occ= 0
MO #351 energy= 11.8483439047676   occ= 0
MO #352 energy= 11.9264376613429   occ= 0
MO #353 energy= 16.7877793331425   occ= 0
MO #354 energy= 16.8807636746251   occ= 0
MO #355 energy= 27.9150298199716   occ= 0
MO #356 energy= 27.9374506096215   occ= 0
MO #357 energy= 31.0818316838048   occ= 0
MO #358 energy= 31.1144129124754   occ= 0
MO #359 energy= 31.1331444236216   occ= 0
MO #360 energy= 31.2152979169802   occ= 0
MO #361 energy= 60.4323559008699   occ= 0
MO #362 energy= 60.4413084493617   occ= 0
MO #363 energy= 60.4662455926282   occ= 0
MO #364 energy= 60.4955036688363   occ= 0
MO #365 energy= 62.6198977959253   occ= 0
MO #366 energy= 62.6411309145015   occ= 0
MO #367 energy= 62.6583673476038   occ= 0
MO #368 energy= 62.6720675997691   occ= 0
MO #369 energy= 62.6908825071696   occ= 0
MO #370 energy= 62.7526504159799   occ= 0
MO #371 energy= 71.9742675927696   occ= 0
MO #372 energy= 72.0426590396519   occ= 0
MO #373 energy= 150.73422157137    occ= 0
MO #374 energy= 150.743547028225   occ= 0
MO #375 energy= 165.183616268237   occ= 0
MO #376 energy= 165.201868450352   occ= 0
MO #377 energy= 165.211268205844   occ= 0
MO #378 energy= 165.245743138798   occ= 0
MO #379 energy= 294.470927483093   occ= 0
MO #380 energy= 294.491324006596   occ= 0
MO #381 energy= 690.538502415378   occ= 0
MO #382 energy= 690.539974838178   occ= 0
MO #383 energy= 798.986517741522   occ= 0
MO #384 energy= 798.989029186739   occ= 0
MO #385 energy= 798.99660058262    occ= 0
MO #386 energy= 799.001208260676   occ= 0
MO #387 energy= 1008.64590703998   occ= 0
MO #388 energy= 1008.64992793613   occ= 0
MO #389 energy= 2865.03491599469   occ= 0
MO #390 energy= 2865.03580816198   occ= 0
MO #391 energy= 6964.91716385598   occ= 0
MO #392 energy= 6964.91742865169   occ= 0
MO #393 energy= 14850.4542907431   occ= 0
MO #394 energy= 14850.454383193    occ= 0
MO #395 energy= 35043.5915802154   occ= 0
MO #396 energy= 35043.5916093596   occ= 0
 ** Mulliken pop alpha/beta on meta-lowdin orthogonal AOs **
 ** Mulliken pop       alpha | beta **
pop of  0 Dy 1s        0.99999 | 0.99999   
pop of  0 Dy 2s        1.00000 | 1.00000   
pop of  0 Dy 3s        1.00000 | 1.00000   
pop of  0 Dy 4s        0.99998 | 0.99999   
pop of  0 Dy 5s        0.99895 | 0.99743   
pop of  0 Dy 6s        0.19411 | 0.20022   
pop of  0 Dy 7s        0.00572 | 0.00744   
pop of  0 Dy 8s        0.00026 | 0.00049   
pop of  0 Dy 9s        0.00022 | 0.00026   
pop of  0 Dy 10s        0.00017 | 0.00018   
pop of  0 Dy 11s        0.00000 | 0.00000   
pop of  0 Dy 12s        0.00001 | 0.00001   
pop of  0 Dy 13s        0.00001 | 0.00001   
pop of  0 Dy 14s        0.00000 | 0.00000   
pop of  0 Dy 15s        0.00000 | 0.00000   
pop of  0 Dy 16s        0.00000 | 0.00000   
pop of  0 Dy 17s        0.00000 | 0.00000   
pop of  0 Dy 18s        0.00000 | 0.00000   
pop of  0 Dy 2px       0.99897 | 0.99897   
pop of  0 Dy 2py       0.99897 | 0.99897   
pop of  0 Dy 2pz       0.99897 | 0.99897   
pop of  0 Dy 3px       0.99875 | 0.99875   
pop of  0 Dy 3py       0.99875 | 0.99875   
pop of  0 Dy 3pz       0.99875 | 0.99875   
pop of  0 Dy 4px       0.99836 | 0.99840   
pop of  0 Dy 4py       0.99836 | 0.99840   
pop of  0 Dy 4pz       0.99836 | 0.99840   
pop of  0 Dy 5px       0.99679 | 0.99511   
pop of  0 Dy 5py       0.99680 | 0.99512   
pop of  0 Dy 5pz       0.99658 | 0.99391   
pop of  0 Dy 6px       0.00549 | 0.00727   
pop of  0 Dy 6py       0.00549 | 0.00727   
pop of  0 Dy 6pz       0.00598 | 0.00847   
pop of  0 Dy 7px       0.00266 | 0.00340   
pop of  0 Dy 7py       0.00266 | 0.00340   
pop of  0 Dy 7pz       0.00280 | 0.00402   
pop of  0 Dy 8px       0.00147 | 0.00160   
pop of  0 Dy 8py       0.00147 | 0.00160   
pop of  0 Dy 8pz       0.00155 | 0.00170   
pop of  0 Dy 9px       0.00067 | 0.00070   
pop of  0 Dy 9py       0.00067 | 0.00070   
pop of  0 Dy 9pz       0.00068 | 0.00072   
pop of  0 Dy 10px       0.00071 | 0.00071   
pop of  0 Dy 10py       0.00071 | 0.00071   
pop of  0 Dy 10pz       0.00069 | 0.00071   
pop of  0 Dy 11px       0.00068 | 0.00068   
pop of  0 Dy 11py       0.00068 | 0.00068   
pop of  0 Dy 11pz       0.00067 | 0.00067   
pop of  0 Dy 12px       0.00059 | 0.00059   
pop of  0 Dy 12py       0.00059 | 0.00059   
pop of  0 Dy 12pz       0.00059 | 0.00059   
pop of  0 Dy 13px       0.00107 | 0.00107   
pop of  0 Dy 13py       0.00107 | 0.00107   
pop of  0 Dy 13pz       0.00107 | 0.00107   
pop of  0 Dy 3dxy      0.99991 | 0.99991   
pop of  0 Dy 3dyz      0.99991 | 0.99991   
pop of  0 Dy 3dz^2     0.99991 | 0.99991   
pop of  0 Dy 3dxz      0.99991 | 0.99991   
pop of  0 Dy 3dx2-y2    0.99991 | 0.99991   
pop of  0 Dy 4dxy      0.99976 | 0.99974   
pop of  0 Dy 4dyz      0.99972 | 0.99973   
pop of  0 Dy 4dz^2     0.99969 | 0.99972   
pop of  0 Dy 4dxz      0.99972 | 0.99973   
pop of  0 Dy 4dx2-y2    0.99976 | 0.99974   
pop of  0 Dy 5dxy      0.01283 | 0.01423   
pop of  0 Dy 5dyz      0.01313 | 0.01503   
pop of  0 Dy 5dz^2     0.03148 | 0.03937   
pop of  0 Dy 5dxz      0.01313 | 0.01504   
pop of  0 Dy 5dx2-y2    0.03058 | 0.03559   
pop of  0 Dy 6dxy      0.00170 | 0.00158   
pop of  0 Dy 6dyz      0.00170 | 0.00155   
pop of  0 Dy 6dz^2     0.00037 | 0.00070   
pop of  0 Dy 6dxz      0.00170 | 0.00155   
pop of  0 Dy 6dx2-y2    0.00032 | 0.00048   
pop of  0 Dy 7dxy      0.00014 | 0.00014   
pop of  0 Dy 7dyz      0.00014 | 0.00014   
pop of  0 Dy 7dz^2     0.00243 | 0.00264   
pop of  0 Dy 7dxz      0.00014 | 0.00014   
pop of  0 Dy 7dx2-y2    0.00232 | 0.00246   
pop of  0 Dy 8dxy      0.00004 | 0.00004   
pop of  0 Dy 8dyz      0.00004 | 0.00003   
pop of  0 Dy 8dz^2     0.00094 | 0.00101   
pop of  0 Dy 8dxz      0.00004 | 0.00003   
pop of  0 Dy 8dx2-y2    0.00092 | 0.00097   
pop of  0 Dy 9dxy      0.00010 | 0.00009   
pop of  0 Dy 9dyz      0.00009 | 0.00008   
pop of  0 Dy 9dz^2     0.00018 | 0.00015   
pop of  0 Dy 9dxz      0.00009 | 0.00008   
pop of  0 Dy 9dx2-y2    0.00019 | 0.00017   
pop of  0 Dy 10dxy      0.00014 | 0.00015   
pop of  0 Dy 10dyz      0.00014 | 0.00015   
pop of  0 Dy 10dz^2     0.00014 | 0.00014   
pop of  0 Dy 10dxz      0.00014 | 0.00015   
pop of  0 Dy 10dx2-y2    0.00014 | 0.00014   
pop of  0 Dy 11dxy      0.00017 | 0.00017   
pop of  0 Dy 11dyz      0.00017 | 0.00018   
pop of  0 Dy 11dz^2     0.00002 | 0.00002   
pop of  0 Dy 11dxz      0.00017 | 0.00018   
pop of  0 Dy 11dx2-y2    0.00002 | 0.00002   
pop of  0 Dy 4f-3      0.50215 | 0.98769   
pop of  0 Dy 4f-2      0.47757 | 0.97989   
pop of  0 Dy 4f-1      0.08234 | 0.97046   
pop of  0 Dy 4f+0      0.04107 | 0.95885   
pop of  0 Dy 4f+1      0.08142 | 0.96955   
pop of  0 Dy 4f+2      0.47698 | 0.97976   
pop of  0 Dy 4f+3      0.50201 | 0.98769   
pop of  0 Dy 5f-3      0.00073 | 0.00152   
pop of  0 Dy 5f-2      0.00011 | 0.00130   
pop of  0 Dy 5f-1      0.00064 | 0.00217   
pop of  0 Dy 5f+0      0.00111 | 0.00272   
pop of  0 Dy 5f+1      0.00064 | 0.00217   
pop of  0 Dy 5f+2      0.00033 | 0.00150   
pop of  0 Dy 5f+3      0.00073 | 0.00152   
pop of  0 Dy 6f-3      0.00182 | 0.00191   
pop of  0 Dy 6f-2      0.00001 | 0.00022   
pop of  0 Dy 6f-1      0.00173 | 0.00189   
pop of  0 Dy 6f+0      0.00223 | 0.00233   
pop of  0 Dy 6f+1      0.00173 | 0.00189   
pop of  0 Dy 6f+2      0.00142 | 0.00159   
pop of  0 Dy 6f+3      0.00182 | 0.00191   
pop of  1 Cl 1s        1.00000 | 1.00000   
pop of  1 Cl 2s        1.00000 | 1.00000   
pop of  1 Cl 3s        0.98084 | 0.98071   
pop of  1 Cl 4s        0.00133 | 0.00151   
pop of  1 Cl 2px       1.00000 | 1.00000   
pop of  1 Cl 2py       1.00000 | 1.00000   
pop of  1 Cl 2pz       1.00000 | 1.00000   
pop of  1 Cl 3px       0.96837 | 0.96519   
pop of  1 Cl 3py       0.99289 | 0.99262   
pop of  1 Cl 3pz       0.99259 | 0.99233   
pop of  1 Cl 4px       0.00176 | 0.00201   
pop of  1 Cl 4py       0.00166 | 0.00171   
pop of  1 Cl 4pz       0.00168 | 0.00175   
pop of  2 Cl 1s        1.00000 | 1.00000   
pop of  2 Cl 2s        1.00000 | 1.00000   
pop of  2 Cl 3s        0.98084 | 0.98071   
pop of  2 Cl 4s        0.00133 | 0.00151   
pop of  2 Cl 2px       1.00000 | 1.00000   
pop of  2 Cl 2py       1.00000 | 1.00000   
pop of  2 Cl 2pz       1.00000 | 1.00000   
pop of  2 Cl 3px       0.96837 | 0.96519   
pop of  2 Cl 3py       0.99289 | 0.99262   
pop of  2 Cl 3pz       0.99259 | 0.99233   
pop of  2 Cl 4px       0.00176 | 0.00201   
pop of  2 Cl 4py       0.00166 | 0.00171   
pop of  2 Cl 4pz       0.00168 | 0.00175   
pop of  3 Cl 1s        1.00000 | 1.00000   
pop of  3 Cl 2s        1.00000 | 1.00000   
pop of  3 Cl 3s        0.98084 | 0.98071   
pop of  3 Cl 4s        0.00133 | 0.00151   
pop of  3 Cl 2px       1.00000 | 1.00000   
pop of  3 Cl 2py       1.00000 | 1.00000   
pop of  3 Cl 2pz       1.00000 | 1.00000   
pop of  3 Cl 3px       0.99288 | 0.99261   
pop of  3 Cl 3py       0.96834 | 0.96517   
pop of  3 Cl 3pz       0.99259 | 0.99232   
pop of  3 Cl 4px       0.00165 | 0.00171   
pop of  3 Cl 4py       0.00175 | 0.00201   
pop of  3 Cl 4pz       0.00168 | 0.00175   
pop of  4 Cl 1s        1.00000 | 1.00000   
pop of  4 Cl 2s        1.00000 | 1.00000   
pop of  4 Cl 3s        0.98084 | 0.98071   
pop of  4 Cl 4s        0.00133 | 0.00151   
pop of  4 Cl 2px       1.00000 | 1.00000   
pop of  4 Cl 2py       1.00000 | 1.00000   
pop of  4 Cl 2pz       1.00000 | 1.00000   
pop of  4 Cl 3px       0.99288 | 0.99262   
pop of  4 Cl 3py       0.96834 | 0.96517   
pop of  4 Cl 3pz       0.99259 | 0.99232   
pop of  4 Cl 4px       0.00165 | 0.00171   
pop of  4 Cl 4py       0.00175 | 0.00201   
pop of  4 Cl 4pz       0.00168 | 0.00175   
pop of  5 Cl 1s        1.00000 | 1.00000   
pop of  5 Cl 2s        1.00000 | 1.00000   
pop of  5 Cl 3s        0.98081 | 0.98069   
pop of  5 Cl 4s        0.00136 | 0.00161   
pop of  5 Cl 2px       1.00000 | 1.00000   
pop of  5 Cl 2py       1.00000 | 1.00000   
pop of  5 Cl 2pz       1.00000 | 1.00000   
pop of  5 Cl 3px       0.99264 | 0.99247   
pop of  5 Cl 3py       0.99264 | 0.99248   
pop of  5 Cl 3pz       0.96758 | 0.96407   
pop of  5 Cl 4px       0.00162 | 0.00168   
pop of  5 Cl 4py       0.00162 | 0.00169   
pop of  5 Cl 4pz       0.00173 | 0.00205   
pop of  6 Cl 1s        1.00000 | 1.00000   
pop of  6 Cl 2s        1.00000 | 1.00000   
pop of  6 Cl 3s        0.98081 | 0.98069   
pop of  6 Cl 4s        0.00136 | 0.00161   
pop of  6 Cl 2px       1.00000 | 1.00000   
pop of  6 Cl 2py       1.00000 | 1.00000   
pop of  6 Cl 2pz       1.00000 | 1.00000   
pop of  6 Cl 3px       0.99264 | 0.99247   
pop of  6 Cl 3py       0.99264 | 0.99248   
pop of  6 Cl 3pz       0.96758 | 0.96407   
pop of  6 Cl 4px       0.00162 | 0.00168   
pop of  6 Cl 4py       0.00162 | 0.00168   
pop of  6 Cl 4pz       0.00173 | 0.00205   
In total            83.15554 | 87.84446  
 ** Mulliken atomic charges   ( Nelec_alpha | Nelec_beta ) **
charge of  0Dy =      2.26895  (    29.51128     34.21977 )
charge of  1Cl =     -0.87892  (     8.94109      8.93783 )
charge of  2Cl =     -0.87892  (     8.94109      8.93783 )
charge of  3Cl =     -0.87883  (     8.94104      8.93778 )
charge of  4Cl =     -0.87884  (     8.94105      8.93779 )
charge of  5Cl =     -0.87673  (     8.93999      8.93673 )
charge of  6Cl =     -0.87672  (     8.93999      8.93673 )
(3, 198, 198) 198
S vector [ 0.335 +0.j -0.2664+0.j -2.3445+0.j]
(3, 198, 198) 198
L vector [ 0.6993-0.j -0.5557-0.j -5.0377+0.j]
(3, 198, 198) 198
J vector [ 1.0343-0.j -0.8221+0.j -7.3822+0.j]
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


ao_index [ 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317]
ao_labels ['0 Dy 4f-3  ' '0 Dy 4f-2  ' '0 Dy 4f-1  ' '0 Dy 4f+0  ' '0 Dy 4f+1  ' '0 Dy 4f+2  ' '0 Dy 4f+3  ' '0 Dy 5f-3  ' '0 Dy 5f-2  ' '0 Dy 5f-1  ' '0 Dy 5f+0  ' '0 Dy 5f+1  ' '0 Dy 5f+2  ' '0 Dy 5f+3  ' '0 Dy 6f-3  ' '0 Dy 6f-2  ' '0 Dy 6f-1  ' '0 Dy 6f+0  ' '0 Dy 6f+1  ' '0 Dy 6f+2  ' '0 Dy 6f+3  ']
rank = 11, idx_lst = [11 27]
rank = 15, idx_lst = [15]
rank = 7, idx_lst = [ 7 23]
rank = 3, idx_lst = [ 3 19]
  J     M     c^2  
rank = 0, idx_lst = [ 0 16]
rank = 8, idx_lst = [ 8 24]
rank = 12, idx_lst = [12 28]
rank = 14, idx_lst = [14]
rank = 5, idx_lst = [ 5 21]
rank = 13, idx_lst = [13]
rank = 4, idx_lst = [ 4 20]
rank = 2, idx_lst = [ 2 18]
rank = 6, idx_lst = [ 6 22]
rank = 10, idx_lst = [10 26]
rank = 1, idx_lst = [ 1 17]
rank = 9, idx_lst = [ 9 25]
[hpc-80-16.cm.cluster:2319471] 15 more processes have sent help message help-mpi-btl-openib.txt / error in device init
[hpc-80-16.cm.cluster:2319471] Set MCA parameter "orte_base_help_aggregate" to 0 to see all help / error messages
 7.5    1.5   -6.5    0.00000    0.00001
 7.5   -0.5   -6.5    0.00001    0.00001
 7.5   -1.5   -3.5   -0.00001   -0.00001
 7.5   -1.5   -4.5   -0.00001
 7.5   -1.5   -5.5    0.00002   -0.00000
 7.5   -1.5   -6.5    0.00003   -0.00004
 7.5   -1.5   -7.5    0.00002   -0.00020
 7.5   -2.5   -3.5    0.00001    0.00001
 7.5   -2.5   -4.5    0.00002    0.00001
 7.5   -2.5   -5.5    0.00006    0.00003
 7.5   -2.5   -6.5    0.00030   -0.00003
 7.5   -2.5   -7.5    0.00065   -0.00063
 7.5   -3.5   -3.5   -0.00001   -0.00000
 7.5   -3.5   -4.5   -0.00005    0.00004
 7.5   -3.5   -5.5    0.00014    0.00005
 7.5   -3.5   -6.5    0.00044   -0.00005
 7.5   -3.5   -7.5    0.00111   -0.00097
 7.5   -4.5   -4.5    0.00013    0.00001
 7.5   -4.5   -5.5    0.00083   -0.00051
 7.5   -4.5   -6.5    0.00118   -0.00396
 7.5   -4.5   -7.5   -0.00439   -0.01115
 7.5   -5.5   -5.5    0.00573    0.00003
 7.5   -5.5   -6.5    0.01933   -0.01538
 7.5   -5.5   -7.5    0.01615   -0.07055
 7.5   -6.5   -6.5    0.10355    0.00006
 7.5   -6.5   -7.5    0.23758   -0.18877
 7.5   -7.5   -7.5    0.88337   -0.00005
triangle [[-0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    -0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j     -0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    -0.j     -0.    -0.j      0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j      0.    +0.j     -0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    -0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    -0.j     -0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j     -0.    -0.j     -0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    +0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j      0.    -0.j      0.    -0.0002j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    +0.j      0.    +0.j      0.    +0.j      0.0001+0.j      0.0003-0.j      0.0007-0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.0001+0.j      0.0004-0.0001j  0.0011-0.001j ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0001+0.j      0.0008-0.0005j  0.0012-0.004j  -0.0044-0.0111j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0057+0.j      0.0193-0.0154j  0.0161-0.0705j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1036+0.0001j  0.2376-0.1888j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.8834-0.j    ]]
full [[-0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    -0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j     -0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    -0.j     -0.    -0.j      0.    -0.j      0.    -0.j    ]
 [ 0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j      0.    +0.j     -0.    +0.j     -0.    +0.j    ]
 [-0.    -0.j      0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    +0.j    ]
 [-0.    -0.j     -0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    -0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    -0.j     -0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j    ]
 [-0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j     -0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j     -0.    -0.j     -0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j    ]
 [-0.    +0.j      0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j      0.    -0.j      0.    -0.0002j]
 [ 0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    +0.j      0.    +0.j      0.0001+0.j      0.0003-0.j      0.0007-0.0006j]
 [-0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    -0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    +0.j      0.0001+0.j      0.0004-0.0001j  0.0011-0.001j ]
 [-0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j     -0.    +0.j      0.    -0.j     -0.    -0.j      0.    -0.j     -0.    -0.j      0.0001+0.j      0.0008-0.0005j  0.0012-0.004j  -0.0044-0.0111j]
 [ 0.    -0.j     -0.    +0.j      0.    -0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    +0.j      0.0001-0.j      0.0001-0.j      0.0008+0.0005j  0.0057+0.j      0.0193-0.0154j  0.0161-0.0705j]
 [-0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j      0.    +0.j      0.0003+0.j      0.0004+0.0001j  0.0012+0.004j   0.0193+0.0154j  0.1036+0.j      0.2376-0.1888j]
 [-0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.0002j  0.0007+0.0006j  0.0011+0.001j  -0.0044+0.0111j  0.0161+0.0705j  0.2376+0.1888j  0.8834+0.j    ]]
Sum of c^2 0.9927697757674856
Thu Apr 17 13:26:59 PDT 2025
