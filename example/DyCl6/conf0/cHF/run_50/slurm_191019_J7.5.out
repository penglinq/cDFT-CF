Currently Loaded Modulefiles:
 1) gmp/6.2.1-gcc-13.2.0-lcnhyse <aL>             
 2) mpfr/4.2.0-gcc-13.2.0-yy2fkq5 <aL>            
 3) mpc/1.3.1-gcc-13.2.0-5kgoftq <aL>             
 4) zlib-ng/2.1.3-gcc-13.2.0-jetnfwa <aL>         
 5) zstd/1.5.5-gcc-13.2.0-t2lua3l <aL>            
 6) gcc/13.2.0-gcc-13.2.0-w55nxkl                 
 7) cmake/3.20.2-gcc-13.2.0-rp74vpv               
 8) libfabric/1.18.1-gcc-13.2.0-bijxar4 <aL>      
 9) numactl/2.0.14-gcc-13.2.0-etkf74e <aL>        
10) openssh/8.7p1-gcc-13.2.0-g55xmkx <aL>         
11) slurm/22.05.6-gcc-13.2.0-tchsn6y <aL>         
12) openmpi/4.1.5-gcc-13.2.0-24q3ap2              
13) libpciaccess/0.17-gcc-13.2.0-r2cijnn <aL>     
14) libiconv/1.17-gcc-13.2.0-ntov4te <aL>         
15) xz/5.4.1-gcc-13.2.0-4xkm5xo <aL>              
16) libxml2/2.10.3-gcc-13.2.0-fr6jcjz <aL>        
17) ncurses/6.4-gcc-13.2.0-4o2yj6n <aL>           
18) hwloc/2.9.1-gcc-13.2.0-gzvfolk <aL>           
19) intel-tbb/2021.9.0-gcc-13.2.0-6nwk3ml <aL>    
20) intel-oneapi-mkl/2023.2.0-gcc-13.2.0-ohvyk7g  

Key:
<module-tag>  <aL>=auto-loaded  
/central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF
Thu Apr 17 13:17:17 PDT 2025
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
hpc-89-17.cm.cluster
--------------------------------------------------------------------------
WARNING: There was an error initializing an OpenFabrics device.

  Local host:   hpc-89-17
  Local device: mlx5_0
--------------------------------------------------------------------------
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:17:20 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      [CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      [INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:#INFO: ******************** input file end ********************


[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   '''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   :
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   :
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.90
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   [INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4

N_elec (88, 83), N_ao 198
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    [INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_50/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
nuclear repulsion = 1868.38919656687
number of shells = 84
CPU time:         0.93
N_elec (88, 83), N_ao 198
System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
number of NR cGTOs = 198
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-89-17.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:17:20 2025
PySCF version 2.5.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.93
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
PySCF version 2.5.0
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.93
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

nuclear repulsion = 1868.38919656687
number of shells = 84
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
CPU time:         0.94
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
CPU time:         0.94
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
[INPUT] num. electrons = 171
[INPUT] charge = -3
number of NR pGTOs = 449
number of NR cGTOs = 198
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
CPU time:         0.94
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
**** MO energy ****
MO #1   energy= -1986.50534916543  occ= 1
MO #2   energy= -1986.50523560409  occ= 1
MO #3   energy= -335.744494137328  occ= 1
MO #4   energy= -335.744037009856  occ= 1
MO #5   energy= -318.560759399933  occ= 1
MO #6   energy= -318.560502610078  occ= 1
MO #7   energy= -288.739774337949  occ= 1
MO #8   energy= -288.739407933417  occ= 1
MO #9   energy= -288.731646399384  occ= 1
MO #10  energy= -288.731522689174  occ= 1
MO #11  energy= -105.082963498742  occ= 1
MO #12  energy= -105.08294192261   occ= 1
MO #13  energy= -105.082829071235  occ= 1
MO #14  energy= -105.082807475351  occ= 1
MO #15  energy= -105.08265827136   occ= 1
MO #16  energy= -105.08263841297   occ= 1
MO #17  energy= -105.082524751145  occ= 1
MO #18  energy= -105.082504874892  occ= 1
MO #19  energy= -105.081713092421  occ= 1
MO #20  energy= -105.081709448528  occ= 1
MO #21  energy= -105.081585153339  occ= 1
MO #22  energy= -105.081581510735  occ= 1
MO #23  energy= -77.0768344174994  occ= 1
MO #24  energy= -76.9573153936046  occ= 1
MO #25  energy= -69.5783247720983  occ= 1
MO #26  energy= -69.5597462251064  occ= 1
MO #27  energy= -63.2150271875913  occ= 1
MO #28  energy= -63.2058856373219  occ= 1
MO #29  energy= -63.1306937607313  occ= 1
MO #30  energy= -63.0453566219087  occ= 1
MO #31  energy= -50.7717883113762  occ= 1
MO #32  energy= -50.7677341616307  occ= 1
MO #33  energy= -50.7600692983316  occ= 1
MO #34  energy= -50.7376245020052  occ= 1
MO #35  energy= -49.1961576602905  occ= 1
MO #36  energy= -49.1797438182645  occ= 1
MO #37  energy= -49.1679055165619  occ= 1
MO #38  energy= -49.0956875792114  occ= 1
MO #39  energy= -49.050139742982   occ= 1
MO #40  energy= -48.9961615931278  occ= 1
MO #41  energy= -16.5561665770714  occ= 1
MO #42  energy= -16.2412557152128  occ= 1
MO #43  energy= -13.4593289389707  occ= 1
MO #44  energy= -13.4141631909073  occ= 1
MO #45  energy= -12.055435172466   occ= 1
MO #46  energy= -12.0154443090434  occ= 1
MO #47  energy= -11.8192587774139  occ= 1
MO #48  energy= -11.6604490078962  occ= 1
MO #49  energy= -10.4900115811632  occ= 1
MO #50  energy= -10.4899902526507  occ= 1
MO #51  energy= -10.4898646411127  occ= 1
MO #52  energy= -10.489843292477   occ= 1
MO #53  energy= -10.4897004792803  occ= 1
MO #54  energy= -10.4896808846807  occ= 1
MO #55  energy= -10.4895544431796  occ= 1
MO #56  energy= -10.4895348302482  occ= 1
MO #57  energy= -10.4887229453033  occ= 1
MO #58  energy= -10.4887211633307  occ= 1
MO #59  energy= -10.488583467045   occ= 1
MO #60  energy= -10.4885816877965  occ= 1
MO #61  energy= -7.94716290698878  occ= 1
MO #62  energy= -7.94714153785061  occ= 1
MO #63  energy= -7.9470506583219   occ= 1
MO #64  energy= -7.94702927168572  occ= 1
MO #65  energy= -7.94685532836332  occ= 1
MO #66  energy= -7.94683569684436  occ= 1
MO #67  energy= -7.94673706920544  occ= 1
MO #68  energy= -7.94671742039476  occ= 1
MO #69  energy= -7.94589740645275  occ= 1
MO #70  energy= -7.94589561840318  occ= 1
MO #71  energy= -7.94575902782924  occ= 1
MO #72  energy= -7.94575723698833  occ= 1
MO #73  energy= -7.87928380688021  occ= 1
MO #74  energy= -7.87926234377138  occ= 1
MO #75  energy= -7.87902444909128  occ= 1
MO #76  energy= -7.87900298196296  occ= 1
MO #77  energy= -7.87897249200281  occ= 1
MO #78  energy= -7.87895281326772  occ= 1
MO #79  energy= -7.87871212612288  occ= 1
MO #80  energy= -7.87869236275566  occ= 1
MO #81  energy= -7.87836355152474  occ= 1
MO #82  energy= -7.87834164556513  occ= 1
MO #83  energy= -7.87827870470985  occ= 1
MO #84  energy= -7.87825677175158  occ= 1
MO #85  energy= -7.87805138432147  occ= 1
MO #86  energy= -7.8780313551735   occ= 1
MO #87  energy= -7.87799640317319  occ= 1
MO #88  energy= -7.87799412719877  occ= 1
MO #89  energy= -7.87797434099977  occ= 1
MO #90  energy= -7.87795412445513  occ= 1
MO #91  energy= -7.87773508125624  occ= 1
MO #92  energy= -7.87773256412297  occ= 1
MO #93  energy= -7.87705175536138  occ= 1
MO #94  energy= -7.87704842676065  occ= 1
MO #95  energy= -7.87704654954423  occ= 1
MO #96  energy= -7.87704320962223  occ= 1
MO #97  energy= -7.14087544153789  occ= 1
MO #98  energy= -7.14052163562807  occ= 1
MO #99  energy= -7.11092443353692  occ= 1
MO #100 energy= -7.0492464172586   occ= 1
MO #101 energy= -6.81804716832642  occ= 1
MO #102 energy= -6.77090589883076  occ= 1
MO #103 energy= -6.61056737874363  occ= 1
MO #104 energy= -6.39848586957642  occ= 1
MO #105 energy= -6.33434943448966  occ= 1
MO #106 energy= -6.23763439162635  occ= 1
MO #107 energy= -2.38439770715505  occ= 1
MO #108 energy= -2.26775133688867  occ= 1
MO #109 energy= -1.41550810125537  occ= 1
MO #110 energy= -1.41181127157937  occ= 1
MO #111 energy= -1.221120503395    occ= 1
MO #112 energy= -1.21525463268881  occ= 1
MO #113 energy= -1.17901629765628  occ= 1
MO #114 energy= -1.13424629043795  occ= 1
MO #115 energy= -0.95308175765581  occ= 1
MO #116 energy= -0.952517805510625 occ= 1
MO #117 energy= -0.944670298644439 occ= 1
MO #118 energy= -0.94377863865968  occ= 1
MO #119 energy= -0.943743033900858 occ= 1
MO #120 energy= -0.942881404862347 occ= 1
MO #121 energy= -0.94176685010456  occ= 1
MO #122 energy= -0.941582972239354 occ= 1
MO #123 energy= -0.937401846073407 occ= 1
MO #124 energy= -0.936971527892025 occ= 1
MO #125 energy= -0.936028131886562 occ= 1
MO #126 energy= -0.933336139027699 occ= 1
MO #127 energy= -0.859050973191859 occ= 1
MO #128 energy= -0.854555392563461 occ= 1
MO #129 energy= -0.83772218183762  occ= 1
MO #130 energy= -0.815654502647386 occ= 1
MO #131 energy= -0.781085679145853 occ= 1
MO #132 energy= -0.777711792762289 occ= 1
MO #133 energy= -0.728051786889196 occ= 1
MO #134 energy= -0.631656909757568 occ= 1
MO #135 energy= -0.617661352951873 occ= 1
MO #136 energy= -0.406346208429844 occ= 1
MO #137 energy= -0.405098088648948 occ= 1
MO #138 energy= -0.382426235731314 occ= 1
MO #139 energy= -0.381783662424369 occ= 1
MO #140 energy= -0.381020153324129 occ= 1
MO #141 energy= -0.380441861147809 occ= 1
MO #142 energy= -0.372213987697031 occ= 1
MO #143 energy= -0.371795524013818 occ= 1
MO #144 energy= -0.371144879444724 occ= 1
MO #145 energy= -0.371052474893424 occ= 1
MO #146 energy= -0.370557846063884 occ= 1
MO #147 energy= -0.370463685793213 occ= 1
MO #148 energy= -0.368617878096889 occ= 1
MO #149 energy= -0.368492790178439 occ= 1
MO #150 energy= -0.36838619110998  occ= 1
MO #151 energy= -0.368052867378029 occ= 1
MO #152 energy= -0.367725562758298 occ= 1
MO #153 energy= -0.366441424261634 occ= 1
MO #154 energy= -0.343157701793628 occ= 1
MO #155 energy= -0.342120865871269 occ= 1
MO #156 energy= -0.341309908954402 occ= 1
MO #157 energy= -0.340870963478324 occ= 1
MO #158 energy= -0.340447341386662 occ= 1
MO #159 energy= -0.340375393663737 occ= 1
MO #160 energy= -0.338215800976687 occ= 1
MO #161 energy= -0.338110106140771 occ= 1
MO #162 energy= -0.335396032819356 occ= 1
MO #163 energy= -0.334864554166136 occ= 1
MO #164 energy= -0.334734980735072 occ= 1
MO #165 energy= -0.334007345099765 occ= 1
MO #166 energy= -0.327131087227799 occ= 1
MO #167 energy= -0.326901701593077 occ= 1
MO #168 energy= -0.324409624613091 occ= 1
MO #169 energy= -0.324137661526381 occ= 1
MO #170 energy= -0.323836149039541 occ= 1
MO #171 energy= -0.323748017390476 occ= 1
MO #172 energy= 0.122822231960849  occ= 0
MO #173 energy= 0.122926907415449  occ= 0
MO #174 energy= 0.123042683860475  occ= 0
MO #175 energy= 0.123048730657411  occ= 0
MO #176 energy= 0.123145073320215  occ= 0
MO #177 energy= 0.123210547350676  occ= 0
MO #178 energy= 0.129594964275092  occ= 0
MO #179 energy= 0.129601889607337  occ= 0
MO #180 energy= 0.129811475081083  occ= 0
MO #181 energy= 0.129816619460614  occ= 0
MO #182 energy= 0.129877865035687  occ= 0
MO #183 energy= 0.129879024630814  occ= 0
MO #184 energy= 0.133444596569929  occ= 0
MO #185 energy= 0.133550179421394  occ= 0
MO #186 energy= 0.153577341033028  occ= 0
MO #187 energy= 0.153743336723464  occ= 0
MO #188 energy= 0.153948681384358  occ= 0
MO #189 energy= 0.154103248341378  occ= 0
MO #190 energy= 0.204618521151757  occ= 0
MO #191 energy= 0.20721220261374   occ= 0
MO #192 energy= 0.215887268892243  occ= 0
MO #193 energy= 0.225407703741463  occ= 0
MO #194 energy= 0.229833857130966  occ= 0
MO #195 energy= 0.238416968305235  occ= 0
MO #196 energy= 0.294010738475588  occ= 0
MO #197 energy= 0.296907047632248  occ= 0
MO #198 energy= 0.297277742770661  occ= 0
MO #199 energy= 0.29827154166569   occ= 0
MO #200 energy= 0.298476867841255  occ= 0
MO #201 energy= 0.298576673898055  occ= 0
MO #202 energy= 0.298870559488515  occ= 0
MO #203 energy= 0.300300392421181  occ= 0
MO #204 energy= 0.310244115381161  occ= 0
MO #205 energy= 0.312289532841528  occ= 0
MO #206 energy= 0.320045488070308  occ= 0
MO #207 energy= 0.322969902572672  occ= 0
MO #208 energy= 0.337112259424672  occ= 0
MO #209 energy= 0.337305941494189  occ= 0
MO #210 energy= 0.338402253011794  occ= 0
MO #211 energy= 0.339619470605091  occ= 0
MO #212 energy= 0.340369376122019  occ= 0
MO #213 energy= 0.341690759530867  occ= 0
MO #214 energy= 0.343538786795258  occ= 0
MO #215 energy= 0.344061471623263  occ= 0
MO #216 energy= 0.348637575801275  occ= 0
MO #217 energy= 0.351141967067028  occ= 0
MO #218 energy= 0.404160093825075  occ= 0
MO #219 energy= 0.411458958015157  occ= 0
MO #220 energy= 0.436188035176228  occ= 0
MO #221 energy= 0.442684109215537  occ= 0
MO #222 energy= 0.465647317873924  occ= 0
MO #223 energy= 0.472614829479566  occ= 0
MO #224 energy= 0.485616682035934  occ= 0
MO #225 energy= 0.494061240424542  occ= 0
MO #226 energy= 0.497719702734722  occ= 0
MO #227 energy= 0.499298492074928  occ= 0
MO #228 energy= 0.516568631734636  occ= 0
MO #229 energy= 0.523588058649543  occ= 0
MO #230 energy= 0.541573419385504  occ= 0
MO #231 energy= 0.547029443408686  occ= 0
MO #232 energy= 0.590700716843433  occ= 0
MO #233 energy= 0.606749639818906  occ= 0
MO #234 energy= 0.607258057158324  occ= 0
MO #235 energy= 0.6078970735333    occ= 0
MO #236 energy= 0.613424157186125  occ= 0
MO #237 energy= 0.615937736021639  occ= 0
MO #238 energy= 0.626858761564553  occ= 0
MO #239 energy= 0.629930561599692  occ= 0
MO #240 energy= 0.630413029679177  occ= 0
MO #241 energy= 0.637084117647868  occ= 0
MO #242 energy= 0.659527273699675  occ= 0
MO #243 energy= 0.67379634990186   occ= 0
MO #244 energy= 0.686983214035963  occ= 0
MO #245 energy= 0.743403786656221  occ= 0
MO #246 energy= 0.744728426273215  occ= 0
MO #247 energy= 0.748613916771769  occ= 0
MO #248 energy= 0.749734588407275  occ= 0
MO #249 energy= 0.770563415340374  occ= 0
MO #250 energy= 0.771059660975062  occ= 0
MO #251 energy= 0.773493229733354  occ= 0
MO #252 energy= 0.774949149585463  occ= 0
MO #253 energy= 0.777291551210476  occ= 0
MO #254 energy= 0.777390489953032  occ= 0
MO #255 energy= 0.77757347938799   occ= 0
MO #256 energy= 0.777618445421191  occ= 0
MO #257 energy= 0.780513082068232  occ= 0
MO #258 energy= 0.780583559409725  occ= 0
MO #259 energy= 0.783520179445977  occ= 0
MO #260 energy= 0.796062072188098  occ= 0
MO #261 energy= 0.801246965328695  occ= 0
MO #262 energy= 0.801671675099071  occ= 0
MO #263 energy= 0.8021031550636    occ= 0
MO #264 energy= 0.804801684875391  occ= 0
MO #265 energy= 0.805232866661072  occ= 0
MO #266 energy= 0.805689121048938  occ= 0
MO #267 energy= 0.806466912276461  occ= 0
MO #268 energy= 0.812460463204333  occ= 0
MO #269 energy= 0.86722120465964   occ= 0
MO #270 energy= 0.867309069879658  occ= 0
MO #271 energy= 0.870002652016632  occ= 0
MO #272 energy= 0.87013153345261   occ= 0
MO #273 energy= 0.870341366166748  occ= 0
MO #274 energy= 0.870376647118405  occ= 0
MO #275 energy= 0.933180410794497  occ= 0
MO #276 energy= 0.933629092410378  occ= 0
MO #277 energy= 0.934083624422935  occ= 0
MO #278 energy= 0.934381959633657  occ= 0
MO #279 energy= 0.937446487453612  occ= 0
MO #280 energy= 0.938197673141634  occ= 0
MO #281 energy= 1.01737618031565   occ= 0
MO #282 energy= 1.01904282172554   occ= 0
MO #283 energy= 1.02033845410184   occ= 0
MO #284 energy= 1.02171741855184   occ= 0
MO #285 energy= 1.02402207754398   occ= 0
MO #286 energy= 1.02495704203523   occ= 0
MO #287 energy= 1.02930514802509   occ= 0
MO #288 energy= 1.04035269658889   occ= 0
MO #289 energy= 1.04353611198966   occ= 0
MO #290 energy= 1.04457972670616   occ= 0
MO #291 energy= 1.09201949095746   occ= 0
MO #292 energy= 1.0920523928134    occ= 0
MO #293 energy= 1.09435546711411   occ= 0
MO #294 energy= 1.09446942593366   occ= 0
MO #295 energy= 1.09467740755095   occ= 0
MO #296 energy= 1.0951500262067    occ= 0
MO #297 energy= 1.10880845027843   occ= 0
MO #298 energy= 1.11178712426799   occ= 0
MO #299 energy= 1.12194984467304   occ= 0
MO #300 energy= 1.12461487950421   occ= 0
MO #301 energy= 1.32560369169029   occ= 0
MO #302 energy= 1.33043256448676   occ= 0
MO #303 energy= 1.37036242837533   occ= 0
MO #304 energy= 1.38314347509215   occ= 0
MO #305 energy= 1.52758713844269   occ= 0
MO #306 energy= 1.53726618718417   occ= 0
MO #307 energy= 1.55384480885471   occ= 0
MO #308 energy= 1.5893915381099    occ= 0
MO #309 energy= 1.6002393122931    occ= 0
MO #310 energy= 1.60429887901904   occ= 0
MO #311 energy= 1.60495023131553   occ= 0
MO #312 energy= 1.61066882594013   occ= 0
MO #313 energy= 1.62182162082849   occ= 0
MO #314 energy= 1.62379858839579   occ= 0
MO #315 energy= 1.64828501380907   occ= 0
MO #316 energy= 1.67767319019106   occ= 0
MO #317 energy= 1.70575200968824   occ= 0
MO #318 energy= 1.7114249924059    occ= 0
MO #319 energy= 1.85477253977794   occ= 0
MO #320 energy= 1.86350185073276   occ= 0
MO #321 energy= 1.87987968736876   occ= 0
MO #322 energy= 1.91813740883068   occ= 0
MO #323 energy= 1.92664862307603   occ= 0
MO #324 energy= 1.93070124702805   occ= 0
MO #325 energy= 2.65043836073202   occ= 0
MO #326 energy= 2.65809863289675   occ= 0
MO #327 energy= 2.68051606912802   occ= 0
MO #328 energy= 2.7094352676601    occ= 0
MO #329 energy= 2.74081447515937   occ= 0
MO #330 energy= 2.76565300162174   occ= 0
MO #331 energy= 2.83583719180855   occ= 0
MO #332 energy= 2.84822026006697   occ= 0
MO #333 energy= 2.89889178297005   occ= 0
MO #334 energy= 2.91346837239966   occ= 0
MO #335 energy= 4.4097999024328    occ= 0
MO #336 energy= 4.4655328339092    occ= 0
MO #337 energy= 5.73102245327695   occ= 0
MO #338 energy= 5.74296495302476   occ= 0
MO #339 energy= 6.24312661843263   occ= 0
MO #340 energy= 6.25318976707178   occ= 0
MO #341 energy= 6.28276028118371   occ= 0
MO #342 energy= 6.34079188618351   occ= 0
MO #343 energy= 11.4094197074259   occ= 0
MO #344 energy= 11.4160001344705   occ= 0
MO #345 energy= 11.4469393257611   occ= 0
MO #346 energy= 11.486459295201    occ= 0
MO #347 energy= 11.7343737446581   occ= 0
MO #348 energy= 11.7581015088572   occ= 0
MO #349 energy= 11.7902732986046   occ= 0
MO #350 energy= 11.7966410430272   occ= 0
MO #351 energy= 11.8711710407049   occ= 0
MO #352 energy= 11.9178342404834   occ= 0
MO #353 energy= 16.7875761711686   occ= 0
MO #354 energy= 16.880556455626    occ= 0
MO #355 energy= 27.914815796007    occ= 0
MO #356 energy= 27.9372844811552   occ= 0
MO #357 energy= 31.0817052344136   occ= 0
MO #358 energy= 31.114171103984    occ= 0
MO #359 energy= 31.1329767026687   occ= 0
MO #360 energy= 31.2150736346732   occ= 0
MO #361 energy= 60.432987369467    occ= 0
MO #362 energy= 60.439698354244    occ= 0
MO #363 energy= 60.4659225577324   occ= 0
MO #364 energy= 60.4957939442902   occ= 0
MO #365 energy= 62.6204545222432   occ= 0
MO #366 energy= 62.6355941694144   occ= 0
MO #367 energy= 62.6591440477412   occ= 0
MO #368 energy= 62.6673264900198   occ= 0
MO #369 energy= 62.7043564544012   occ= 0
MO #370 energy= 62.7472867377628   occ= 0
MO #371 energy= 71.9740808996295   occ= 0
MO #372 energy= 72.042467136518    occ= 0
MO #373 energy= 150.734036235271   occ= 0
MO #374 energy= 150.743366123961   occ= 0
MO #375 energy= 165.183455839199   occ= 0
MO #376 energy= 165.201694061138   occ= 0
MO #377 energy= 165.211071364283   occ= 0
MO #378 energy= 165.245545097157   occ= 0
MO #379 energy= 294.470747475018   occ= 0
MO #380 energy= 294.491141164135   occ= 0
MO #381 energy= 690.538320998183   occ= 0
MO #382 energy= 690.539796557942   occ= 0
MO #383 energy= 798.986345691678   occ= 0
MO #384 energy= 798.98885346565    occ= 0
MO #385 energy= 798.996415193717   occ= 0
MO #386 energy= 799.001023387908   occ= 0
MO #387 energy= 1008.64572795631   occ= 0
MO #388 energy= 1008.64974744863   occ= 0
MO #389 energy= 2865.03473727137   occ= 0
MO #390 energy= 2865.03562877934   occ= 0
MO #391 energy= 6964.91698552149   occ= 0
MO #392 energy= 6964.91725000491   occ= 0
MO #393 energy= 14850.4541127158   occ= 0
MO #394 energy= 14850.4542050127   occ= 0
MO #395 energy= 35043.5914024407   occ= 0
MO #396 energy= 35043.5914315081   occ= 0
 ** Mulliken pop alpha/beta on meta-lowdin orthogonal AOs **
 ** Mulliken pop       alpha | beta **
pop of  0 Dy 1s        0.99999 | 0.99999   
pop of  0 Dy 2s        1.00000 | 1.00000   
pop of  0 Dy 3s        1.00000 | 1.00000   
pop of  0 Dy 4s        0.99999 | 0.99998   
pop of  0 Dy 5s        0.99767 | 0.99871   
pop of  0 Dy 6s        0.19931 | 0.19514   
pop of  0 Dy 7s        0.00717 | 0.00600   
pop of  0 Dy 8s        0.00045 | 0.00029   
pop of  0 Dy 9s        0.00025 | 0.00023   
pop of  0 Dy 10s        0.00018 | 0.00017   
pop of  0 Dy 11s        0.00000 | 0.00000   
pop of  0 Dy 12s        0.00001 | 0.00001   
pop of  0 Dy 13s        0.00001 | 0.00001   
pop of  0 Dy 14s        0.00000 | 0.00000   
pop of  0 Dy 15s        0.00000 | 0.00000   
pop of  0 Dy 16s        0.00000 | 0.00000   
pop of  0 Dy 17s        0.00000 | 0.00000   
pop of  0 Dy 18s        0.00000 | 0.00000   
pop of  0 Dy 2px       0.99897 | 0.99897   
pop of  0 Dy 2py       0.99897 | 0.99897   
pop of  0 Dy 2pz       0.99897 | 0.99897   
pop of  0 Dy 3px       0.99875 | 0.99875   
pop of  0 Dy 3py       0.99874 | 0.99875   
pop of  0 Dy 3pz       0.99875 | 0.99875   
pop of  0 Dy 4px       0.99839 | 0.99837   
pop of  0 Dy 4py       0.99839 | 0.99838   
pop of  0 Dy 4pz       0.99840 | 0.99836   
pop of  0 Dy 5px       0.99540 | 0.99654   
pop of  0 Dy 5py       0.99485 | 0.99628   
pop of  0 Dy 5pz       0.99485 | 0.99641   
pop of  0 Dy 6px       0.00697 | 0.00576   
pop of  0 Dy 6py       0.00760 | 0.00611   
pop of  0 Dy 6pz       0.00750 | 0.00606   
pop of  0 Dy 7px       0.00327 | 0.00277   
pop of  0 Dy 7py       0.00355 | 0.00293   
pop of  0 Dy 7pz       0.00356 | 0.00284   
pop of  0 Dy 8px       0.00158 | 0.00149   
pop of  0 Dy 8py       0.00163 | 0.00153   
pop of  0 Dy 8pz       0.00161 | 0.00153   
pop of  0 Dy 9px       0.00070 | 0.00067   
pop of  0 Dy 9py       0.00071 | 0.00068   
pop of  0 Dy 9pz       0.00070 | 0.00068   
pop of  0 Dy 10px       0.00071 | 0.00071   
pop of  0 Dy 10py       0.00071 | 0.00070   
pop of  0 Dy 10pz       0.00071 | 0.00070   
pop of  0 Dy 11px       0.00068 | 0.00068   
pop of  0 Dy 11py       0.00068 | 0.00067   
pop of  0 Dy 11pz       0.00068 | 0.00067   
pop of  0 Dy 12px       0.00059 | 0.00059   
pop of  0 Dy 12py       0.00059 | 0.00059   
pop of  0 Dy 12pz       0.00059 | 0.00059   
pop of  0 Dy 13px       0.00107 | 0.00107   
pop of  0 Dy 13py       0.00107 | 0.00107   
pop of  0 Dy 13pz       0.00107 | 0.00107   
pop of  0 Dy 3dxy      0.99991 | 0.99991   
pop of  0 Dy 3dyz      0.99991 | 0.99991   
pop of  0 Dy 3dz^2     0.99991 | 0.99991   
pop of  0 Dy 3dxz      0.99991 | 0.99991   
pop of  0 Dy 3dx2-y2    0.99991 | 0.99991   
pop of  0 Dy 4dxy      0.99973 | 0.99974   
pop of  0 Dy 4dyz      0.99972 | 0.99971   
pop of  0 Dy 4dz^2     0.99973 | 0.99972   
pop of  0 Dy 4dxz      0.99974 | 0.99974   
pop of  0 Dy 4dx2-y2    0.99973 | 0.99974   
pop of  0 Dy 5dxy      0.01442 | 0.01323   
pop of  0 Dy 5dyz      0.01504 | 0.01343   
pop of  0 Dy 5dz^2     0.03634 | 0.03242   
pop of  0 Dy 5dxz      0.01431 | 0.01324   
pop of  0 Dy 5dx2-y2    0.03617 | 0.03184   
pop of  0 Dy 6dxy      0.00158 | 0.00168   
pop of  0 Dy 6dyz      0.00162 | 0.00172   
pop of  0 Dy 6dz^2     0.00052 | 0.00038   
pop of  0 Dy 6dxz      0.00159 | 0.00167   
pop of  0 Dy 6dx2-y2    0.00053 | 0.00036   
pop of  0 Dy 7dxy      0.00014 | 0.00014   
pop of  0 Dy 7dyz      0.00014 | 0.00014   
pop of  0 Dy 7dz^2     0.00252 | 0.00242   
pop of  0 Dy 7dxz      0.00014 | 0.00014   
pop of  0 Dy 7dx2-y2    0.00250 | 0.00239   
pop of  0 Dy 8dxy      0.00004 | 0.00004   
pop of  0 Dy 8dyz      0.00004 | 0.00004   
pop of  0 Dy 8dz^2     0.00098 | 0.00094   
pop of  0 Dy 8dxz      0.00004 | 0.00004   
pop of  0 Dy 8dx2-y2    0.00098 | 0.00094   
pop of  0 Dy 9dxy      0.00009 | 0.00009   
pop of  0 Dy 9dyz      0.00008 | 0.00009   
pop of  0 Dy 9dz^2     0.00017 | 0.00018   
pop of  0 Dy 9dxz      0.00009 | 0.00009   
pop of  0 Dy 9dx2-y2    0.00017 | 0.00018   
pop of  0 Dy 10dxy      0.00015 | 0.00014   
pop of  0 Dy 10dyz      0.00015 | 0.00014   
pop of  0 Dy 10dz^2     0.00014 | 0.00014   
pop of  0 Dy 10dxz      0.00015 | 0.00014   
pop of  0 Dy 10dx2-y2    0.00014 | 0.00014   
pop of  0 Dy 11dxy      0.00018 | 0.00017   
pop of  0 Dy 11dyz      0.00018 | 0.00017   
pop of  0 Dy 11dz^2     0.00002 | 0.00002   
pop of  0 Dy 11dxz      0.00018 | 0.00017   
pop of  0 Dy 11dx2-y2    0.00002 | 0.00002   
pop of  0 Dy 4f-3      0.91992 | 0.45953   
pop of  0 Dy 4f-2      0.85989 | 0.34719   
pop of  0 Dy 4f-1      0.84475 | 0.24800   
pop of  0 Dy 4f+0      0.83505 | 0.45887   
pop of  0 Dy 4f+1      0.86152 | 0.58314   
pop of  0 Dy 4f+2      0.85455 | 0.36851   
pop of  0 Dy 4f+3      0.92462 | 0.43099   
pop of  0 Dy 5f-3      0.00169 | 0.00095   
pop of  0 Dy 5f-2      0.00123 | 0.00032   
pop of  0 Dy 5f-1      0.00189 | 0.00086   
pop of  0 Dy 5f+0      0.00209 | 0.00122   
pop of  0 Dy 5f+1      0.00150 | 0.00075   
pop of  0 Dy 5f+2      0.00144 | 0.00055   
pop of  0 Dy 5f+3      0.00170 | 0.00095   
pop of  0 Dy 6f-3      0.00196 | 0.00189   
pop of  0 Dy 6f-2      0.00020 | 0.00005   
pop of  0 Dy 6f-1      0.00187 | 0.00177   
pop of  0 Dy 6f+0      0.00225 | 0.00216   
pop of  0 Dy 6f+1      0.00179 | 0.00169   
pop of  0 Dy 6f+2      0.00158 | 0.00146   
pop of  0 Dy 6f+3      0.00195 | 0.00188   
pop of  1 Cl 1s        1.00000 | 1.00000   
pop of  1 Cl 2s        1.00000 | 1.00000   
pop of  1 Cl 3s        0.98073 | 0.98082   
pop of  1 Cl 4s        0.00148 | 0.00136   
pop of  1 Cl 2px       1.00000 | 1.00000   
pop of  1 Cl 2py       1.00000 | 1.00000   
pop of  1 Cl 2pz       1.00000 | 1.00000   
pop of  1 Cl 3px       0.96567 | 0.96783   
pop of  1 Cl 3py       0.99251 | 0.99269   
pop of  1 Cl 3pz       0.99253 | 0.99272   
pop of  1 Cl 4px       0.00197 | 0.00180   
pop of  1 Cl 4py       0.00172 | 0.00168   
pop of  1 Cl 4pz       0.00172 | 0.00168   
pop of  2 Cl 1s        1.00000 | 1.00000   
pop of  2 Cl 2s        1.00000 | 1.00000   
pop of  2 Cl 3s        0.98073 | 0.98082   
pop of  2 Cl 4s        0.00148 | 0.00136   
pop of  2 Cl 2px       1.00000 | 1.00000   
pop of  2 Cl 2py       1.00000 | 1.00000   
pop of  2 Cl 2pz       1.00000 | 1.00000   
pop of  2 Cl 3px       0.96567 | 0.96783   
pop of  2 Cl 3py       0.99251 | 0.99269   
pop of  2 Cl 3pz       0.99253 | 0.99272   
pop of  2 Cl 4px       0.00197 | 0.00180   
pop of  2 Cl 4py       0.00172 | 0.00168   
pop of  2 Cl 4pz       0.00172 | 0.00168   
pop of  3 Cl 1s        1.00000 | 1.00000   
pop of  3 Cl 2s        1.00000 | 1.00000   
pop of  3 Cl 3s        0.98073 | 0.98081   
pop of  3 Cl 4s        0.00153 | 0.00138   
pop of  3 Cl 2px       1.00000 | 1.00000   
pop of  3 Cl 2py       1.00000 | 1.00000   
pop of  3 Cl 2pz       1.00000 | 1.00000   
pop of  3 Cl 3px       0.99260 | 0.99277   
pop of  3 Cl 3py       0.96525 | 0.96743   
pop of  3 Cl 3pz       0.99237 | 0.99257   
pop of  3 Cl 4px       0.00169 | 0.00164   
pop of  3 Cl 4py       0.00199 | 0.00179   
pop of  3 Cl 4pz       0.00171 | 0.00166   
pop of  4 Cl 1s        1.00000 | 1.00000   
pop of  4 Cl 2s        1.00000 | 1.00000   
pop of  4 Cl 3s        0.98073 | 0.98081   
pop of  4 Cl 4s        0.00153 | 0.00138   
pop of  4 Cl 2px       1.00000 | 1.00000   
pop of  4 Cl 2py       1.00000 | 1.00000   
pop of  4 Cl 2pz       1.00000 | 1.00000   
pop of  4 Cl 3px       0.99260 | 0.99277   
pop of  4 Cl 3py       0.96526 | 0.96744   
pop of  4 Cl 3pz       0.99237 | 0.99257   
pop of  4 Cl 4px       0.00169 | 0.00164   
pop of  4 Cl 4py       0.00199 | 0.00179   
pop of  4 Cl 4pz       0.00171 | 0.00166   
pop of  5 Cl 1s        1.00000 | 1.00000   
pop of  5 Cl 2s        1.00000 | 1.00000   
pop of  5 Cl 3s        0.98072 | 0.98083   
pop of  5 Cl 4s        0.00152 | 0.00138   
pop of  5 Cl 2px       1.00000 | 1.00000   
pop of  5 Cl 2py       1.00000 | 1.00000   
pop of  5 Cl 2pz       1.00000 | 1.00000   
pop of  5 Cl 3px       0.99258 | 0.99281   
pop of  5 Cl 3py       0.99236 | 0.99253   
pop of  5 Cl 3pz       0.96529 | 0.96758   
pop of  5 Cl 4px       0.00169 | 0.00165   
pop of  5 Cl 4py       0.00171 | 0.00166   
pop of  5 Cl 4pz       0.00198 | 0.00180   
pop of  6 Cl 1s        1.00000 | 1.00000   
pop of  6 Cl 2s        1.00000 | 1.00000   
pop of  6 Cl 3s        0.98072 | 0.98083   
pop of  6 Cl 4s        0.00152 | 0.00138   
pop of  6 Cl 2px       1.00000 | 1.00000   
pop of  6 Cl 2py       1.00000 | 1.00000   
pop of  6 Cl 2pz       1.00000 | 1.00000   
pop of  6 Cl 3px       0.99258 | 0.99281   
pop of  6 Cl 3py       0.99236 | 0.99253   
pop of  6 Cl 3pz       0.96529 | 0.96757   
pop of  6 Cl 4px       0.00169 | 0.00165   
pop of  6 Cl 4py       0.00171 | 0.00166   
pop of  6 Cl 4pz       0.00198 | 0.00180   
In total            87.10813 | 83.89187  
 ** Mulliken atomic charges   ( Nelec_alpha | Nelec_beta ) **
charge of  0Dy =      2.26971  (    33.48008     30.25021 )
charge of  1Cl =     -0.87888  (     8.93832      8.94055 )
charge of  2Cl =     -0.87888  (     8.93832      8.94055 )
charge of  3Cl =     -0.87791  (     8.93786      8.94005 )
charge of  4Cl =     -0.87792  (     8.93786      8.94006 )
charge of  5Cl =     -0.87807  (     8.93785      8.94022 )
charge of  6Cl =     -0.87806  (     8.93784      8.94022 )
(3, 198, 198) 198
S vector [-0.0071+0.j  1.7587-0.j  1.6081+0.j]
(3, 198, 198) 198
L vector [-0.0148+0.j  3.7787-0.j  3.4462-0.j]
(3, 198, 198) 198
J vector [-0.022 -0.j  5.5374-0.j  5.0543+0.j]
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

WARN: LO is not orthonormal!

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!




WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

ao_index [ 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317]
ao_labels ['0 Dy 4f-3  ' '0 Dy 4f-2  ' '0 Dy 4f-1  ' '0 Dy 4f+0  ' '0 Dy 4f+1  ' '0 Dy 4f+2  ' '0 Dy 4f+3  ' '0 Dy 5f-3  ' '0 Dy 5f-2  ' '0 Dy 5f-1  ' '0 Dy 5f+0  ' '0 Dy 5f+1  ' '0 Dy 5f+2  ' '0 Dy 5f+3  ' '0 Dy 6f-3  ' '0 Dy 6f-2  ' '0 Dy 6f-1  ' '0 Dy 6f+0  ' '0 Dy 6f+1  ' '0 Dy 6f+2  ' '0 Dy 6f+3  ']
  J     M     c^2  
rank = 0, idx_lst = [ 0 16]
rank = 4, idx_lst = [ 4 20]
rank = 9, idx_lst = [ 9 25]
rank = 15, idx_lst = [15]
rank = 8, idx_lst = [ 8 24]
rank = 6, idx_lst = [ 6 22]
rank = 5, idx_lst = [ 5 21]
rank = 12, idx_lst = [12 28]
rank = 1, idx_lst = [ 1 17]
rank = 14, idx_lst = [14]
rank = 7, idx_lst = [ 7 23]
rank = 13, idx_lst = [13]
rank = 11, idx_lst = [11 27]
rank = 2, idx_lst = [ 2 18]
rank = 3, idx_lst = [ 3 19]
rank = 10, idx_lst = [10 26]
[hpc-89-17.cm.cluster:41675] 15 more processes have sent help message help-mpi-btl-openib.txt / error in device init
[hpc-89-17.cm.cluster:41675] Set MCA parameter "orte_base_help_aggregate" to 0 to see all help / error messages
 7.5    7.5    7.5    0.07504   -0.00005
 7.5    7.5    6.5   -0.00041    0.12406
 7.5    7.5    5.5   -0.14171   -0.00109
 7.5    7.5    4.5    0.00154   -0.12946
 7.5    7.5    3.5    0.10029    0.00160
 7.5    7.5    2.5   -0.00134    0.06770
 7.5    7.5    1.5   -0.04023   -0.00094
 7.5    7.5    0.5    0.00056   -0.02107
 7.5    7.5   -0.5    0.00969    0.00028
 7.5    7.5   -1.5   -0.00012    0.00389
 7.5    7.5   -2.5   -0.00136   -0.00004
 7.5    7.5   -3.5    0.00001   -0.00042
 7.5    7.5   -4.5    0.00011    0.00000
 7.5    7.5   -5.5   -0.00000    0.00003
 7.5    6.5    6.5    0.20493   -0.00015
 7.5    6.5    5.5   -0.00082    0.23399
 7.5    6.5    4.5   -0.21374   -0.00166
 7.5    6.5    3.5    0.00197   -0.16559
 7.5    6.5    2.5    0.11179    0.00178
 7.5    6.5    1.5   -0.00133    0.06644
 7.5    6.5    0.5   -0.03479   -0.00083
 7.5    6.5   -0.5    0.00044   -0.01599
 7.5    6.5   -1.5    0.00643    0.00019
 7.5    6.5   -2.5   -0.00006    0.00226
 7.5    6.5   -3.5   -0.00070   -0.00002
 7.5    6.5   -4.5    0.00001   -0.00019
 7.5    6.5   -5.5    0.00004    0.00000
 7.5    5.5    5.5    0.26706   -0.00017
 7.5    5.5    4.5   -0.00085    0.24390
 7.5    5.5    3.5   -0.18896   -0.00143
 7.5    5.5    2.5    0.00149   -0.12755
 7.5    5.5    1.5    0.07581    0.00119
 7.5    5.5    0.5   -0.00079    0.03970
 7.5    5.5   -0.5   -0.01826   -0.00044
 7.5    5.5   -1.5    0.00021   -0.00733
 7.5    5.5   -2.5    0.00256    0.00008
 7.5    5.5   -3.5   -0.00002    0.00078
 7.5    5.5   -4.5   -0.00022
 7.5    5.5   -5.5   -0.00000   -0.00006
 7.5    5.5   -6.5    0.00002    0.00000
 7.5    4.5    4.5    0.22268   -0.00014
 7.5    4.5    3.5   -0.00058    0.17248
 7.5    4.5    2.5   -0.11643   -0.00085
 7.5    4.5    1.5    0.00078   -0.06919
 7.5    4.5    0.5    0.03624    0.00055
 7.5    4.5   -0.5   -0.00032    0.01667
 7.5    4.5   -1.5   -0.00670   -0.00016
 7.5    4.5   -2.5    0.00007   -0.00235
 7.5    4.5   -3.5    0.00072    0.00003
 7.5    4.5   -4.5   -0.00001    0.00019
 7.5    4.5   -5.5   -0.00004   -0.00000
 7.5    3.5    3.5    0.13356   -0.00009
 7.5    3.5    2.5   -0.00029    0.09014
 7.5    3.5    1.5   -0.05356   -0.00038
 7.5    3.5    0.5    0.00031   -0.02804
 7.5    3.5   -0.5    0.01290    0.00019
 7.5    3.5   -1.5   -0.00009    0.00519
 7.5    3.5   -2.5   -0.00182   -0.00003
 7.5    3.5   -3.5    0.00001   -0.00056
 7.5    3.5   -4.5    0.00016    0.00000
 7.5    3.5   -5.5   -0.00000    0.00004
 7.5    2.5    2.5    0.06082   -0.00004
 7.5    2.5    1.5   -0.00012    0.03613
 7.5    2.5    0.5   -0.01891   -0.00013
 7.5    2.5   -0.5    0.00009   -0.00869
 7.5    2.5   -1.5    0.00349    0.00004
 7.5    2.5   -2.5   -0.00001    0.00123
 7.5    2.5   -3.5   -0.00037    0.00000
 7.5    2.5   -4.5   -0.00001   -0.00010
 7.5    2.5   -5.5    0.00003   -0.00001
 7.5    1.5    1.5    0.02145   -0.00001
 7.5    1.5    0.5   -0.00004    0.01121
 7.5    1.5   -0.5   -0.00514   -0.00003
 7.5    1.5   -1.5    0.00001   -0.00206
 7.5    1.5   -2.5    0.00072
 7.5    1.5   -3.5    0.00000    0.00022
 7.5    1.5   -4.5   -0.00006   -0.00000
 7.5    1.5   -5.5    0.00000   -0.00001
 7.5    0.5    0.5    0.00586   -0.00001
 7.5    0.5   -0.5   -0.00000    0.00268
 7.5    0.5   -1.5   -0.00107
 7.5    0.5   -2.5   -0.00001   -0.00037
 7.5    0.5   -3.5    0.00011   -0.00001
 7.5    0.5   -4.5    0.00000    0.00004
 7.5    0.5   -5.5   -0.00001
 7.5   -0.5   -0.5    0.00122   -0.00000
 7.5   -0.5   -1.5   -0.00000    0.00048
 7.5   -0.5   -2.5   -0.00016    0.00000
 7.5   -0.5   -3.5   -0.00001   -0.00004
 7.5   -0.5   -4.5    0.00001   -0.00001
 7.5   -1.5   -1.5    0.00019
 7.5   -1.5   -2.5   -0.00000    0.00006
 7.5   -1.5   -3.5   -0.00001   -0.00000
 7.5   -2.5   -2.5    0.00002    0.00001
 7.5   -2.5   -3.5   -0.00001    0.00000
triangle [[ 0.075 -0.j     -0.0004+0.1241j -0.1417-0.0011j  0.0015-0.1295j  0.1003+0.0016j -0.0013+0.0677j -0.0402-0.0009j  0.0006-0.0211j  0.0097+0.0003j -0.0001+0.0039j -0.0014-0.j      0.    -0.0004j  0.0001+0.j     -0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.2049-0.0001j -0.0008+0.234j  -0.2137-0.0017j  0.002 -0.1656j  0.1118+0.0018j -0.0013+0.0664j -0.0348-0.0008j  0.0004-0.016j   0.0064+0.0002j -0.0001+0.0023j -0.0007-0.j      0.    -0.0002j  0.    +0.j     -0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.2671-0.0002j -0.0009+0.2439j -0.189 -0.0014j  0.0015-0.1275j  0.0758+0.0012j -0.0008+0.0397j -0.0183-0.0004j  0.0002-0.0073j  0.0026+0.0001j -0.    +0.0008j -0.0002-0.j     -0.    -0.0001j  0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.2227-0.0001j -0.0006+0.1725j -0.1164-0.0008j  0.0008-0.0692j  0.0362+0.0006j -0.0003+0.0167j -0.0067-0.0002j  0.0001-0.0024j  0.0007+0.j     -0.    +0.0002j -0.    -0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1336-0.0001j -0.0003+0.0901j -0.0536-0.0004j  0.0003-0.028j   0.0129+0.0002j -0.0001+0.0052j -0.0018-0.j      0.    -0.0006j  0.0002+0.j     -0.    +0.j     -0.    -0.j      0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0608-0.j     -0.0001+0.0361j -0.0189-0.0001j  0.0001-0.0087j  0.0035+0.j     -0.    +0.0012j -0.0004+0.j     -0.    -0.0001j  0.    -0.j      0.    +0.j     -0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0215-0.j     -0.    +0.0112j -0.0051-0.j      0.    -0.0021j  0.0007-0.j      0.    +0.0002j -0.0001-0.j      0.    -0.j      0.    -0.j      0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0059-0.j     -0.    +0.0027j -0.0011-0.j     -0.    -0.0004j  0.0001-0.j      0.    +0.j     -0.    +0.j      0.    +0.j     -0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0012-0.j     -0.    +0.0005j -0.0002+0.j     -0.    -0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0002+0.j     -0.    +0.0001j -0.    -0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j    ]]
full [[ 0.075 +0.j     -0.0004+0.1241j -0.1417-0.0011j  0.0015-0.1295j  0.1003+0.0016j -0.0013+0.0677j -0.0402-0.0009j  0.0006-0.0211j  0.0097+0.0003j -0.0001+0.0039j -0.0014-0.j      0.    -0.0004j  0.0001+0.j     -0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [-0.0004-0.1241j  0.2049+0.j     -0.0008+0.234j  -0.2137-0.0017j  0.002 -0.1656j  0.1118+0.0018j -0.0013+0.0664j -0.0348-0.0008j  0.0004-0.016j   0.0064+0.0002j -0.0001+0.0023j -0.0007-0.j      0.    -0.0002j  0.    +0.j     -0.    +0.j     -0.    +0.j    ]
 [-0.1417+0.0011j -0.0008-0.234j   0.2671+0.j     -0.0009+0.2439j -0.189 -0.0014j  0.0015-0.1275j  0.0758+0.0012j -0.0008+0.0397j -0.0183-0.0004j  0.0002-0.0073j  0.0026+0.0001j -0.    +0.0008j -0.0002-0.j     -0.    -0.0001j  0.    +0.j     -0.    +0.j    ]
 [ 0.0015+0.1295j -0.2137+0.0017j -0.0009-0.2439j  0.2227+0.j     -0.0006+0.1725j -0.1164-0.0008j  0.0008-0.0692j  0.0362+0.0006j -0.0003+0.0167j -0.0067-0.0002j  0.0001-0.0024j  0.0007+0.j     -0.    +0.0002j -0.    -0.j     -0.    -0.j      0.    -0.j    ]
 [ 0.1003-0.0016j  0.002 +0.1656j -0.189 +0.0014j -0.0006-0.1725j  0.1336+0.j     -0.0003+0.0901j -0.0536-0.0004j  0.0003-0.028j   0.0129+0.0002j -0.0001+0.0052j -0.0018-0.j      0.    -0.0006j  0.0002+0.j     -0.    +0.j     -0.    -0.j      0.    +0.j    ]
 [-0.0013-0.0677j  0.1118-0.0018j  0.0015+0.1275j -0.1164+0.0008j -0.0003-0.0901j  0.0608+0.j     -0.0001+0.0361j -0.0189-0.0001j  0.0001-0.0087j  0.0035+0.j     -0.    +0.0012j -0.0004+0.j     -0.    -0.0001j  0.    -0.j      0.    +0.j     -0.    -0.j    ]
 [-0.0402+0.0009j -0.0013-0.0664j  0.0758-0.0012j  0.0008+0.0692j -0.0536+0.0004j -0.0001-0.0361j  0.0215+0.j     -0.    +0.0112j -0.0051-0.j      0.    -0.0021j  0.0007-0.j      0.    +0.0002j -0.0001-0.j      0.    -0.j      0.    -0.j      0.    +0.j    ]
 [ 0.0006+0.0211j -0.0348+0.0008j -0.0008-0.0397j  0.0362-0.0006j  0.0003+0.028j  -0.0189+0.0001j -0.    -0.0112j  0.0059+0.j     -0.    +0.0027j -0.0011-0.j     -0.    -0.0004j  0.0001-0.j      0.    +0.j     -0.    +0.j      0.    +0.j     -0.    -0.j    ]
 [ 0.0097-0.0003j  0.0004+0.016j  -0.0183+0.0004j -0.0003-0.0167j  0.0129-0.0002j  0.0001+0.0087j -0.0051+0.j     -0.    -0.0027j  0.0012+0.j     -0.    +0.0005j -0.0002+0.j     -0.    -0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j    ]
 [-0.0001-0.0039j  0.0064-0.0002j  0.0002+0.0073j -0.0067+0.0002j -0.0001-0.0052j  0.0035-0.j      0.    +0.0021j -0.0011+0.j     -0.    -0.0005j  0.0002+0.j     -0.    +0.0001j -0.    -0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j    ]
 [-0.0014+0.j     -0.0001-0.0023j  0.0026-0.0001j  0.0001+0.0024j -0.0018+0.j     -0.    -0.0012j  0.0007+0.j     -0.    +0.0004j -0.0002-0.j     -0.    -0.0001j  0.    +0.j     -0.    +0.j      0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j    ]
 [ 0.    +0.0004j -0.0007+0.j     -0.    -0.0008j  0.0007-0.j      0.    +0.0006j -0.0004-0.j      0.    -0.0002j  0.0001+0.j     -0.    +0.j     -0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j    ]
 [ 0.0001-0.j      0.    +0.0002j -0.0002+0.j     -0.    -0.0002j  0.0002-0.j     -0.    +0.0001j -0.0001+0.j      0.    -0.j      0.    +0.j      0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j     -0.    -0.j      0.    -0.j    ]
 [-0.    -0.j      0.    -0.j     -0.    +0.0001j -0.    +0.j     -0.    -0.j      0.    +0.j      0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j     -0.    -0.j      0.    +0.j      0.    +0.j     -0.    +0.j    ]
 [-0.    +0.j     -0.    -0.j      0.    -0.j     -0.    +0.j     -0.    +0.j      0.    -0.j      0.    +0.j      0.    -0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j    ]
 [ 0.    +0.j     -0.    -0.j     -0.    -0.j      0.    +0.j      0.    -0.j     -0.    +0.j      0.    -0.j     -0.    +0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    -0.j      0.    +0.j     -0.    +0.j    ]]
Sum of c^2 0.9928260385307766
Thu Apr 17 13:24:23 PDT 2025
