Currently Loaded Modulefiles:
 1) gmp/6.2.1-gcc-13.2.0-lcnhyse <aL>             
 2) mpfr/4.2.0-gcc-13.2.0-yy2fkq5 <aL>            
 3) mpc/1.3.1-gcc-13.2.0-5kgoftq <aL>             
 4) zlib-ng/2.1.3-gcc-13.2.0-jetnfwa <aL>         
 5) zstd/1.5.5-gcc-13.2.0-t2lua3l <aL>            
 6) gcc/13.2.0-gcc-13.2.0-w55nxkl                 
 7) cmake/3.20.2-gcc-13.2.0-rp74vpv               
 8) libfabric/1.18.1-gcc-13.2.0-bijxar4 <aL>      
 9) numactl/2.0.14-gcc-13.2.0-etkf74e <aL>        
10) openssh/8.7p1-gcc-13.2.0-g55xmkx <aL>         
11) slurm/22.05.6-gcc-13.2.0-tchsn6y <aL>         
12) openmpi/4.1.5-gcc-13.2.0-24q3ap2              
13) libpciaccess/0.17-gcc-13.2.0-r2cijnn <aL>     
14) libiconv/1.17-gcc-13.2.0-ntov4te <aL>         
15) xz/5.4.1-gcc-13.2.0-4xkm5xo <aL>              
16) libxml2/2.10.3-gcc-13.2.0-fr6jcjz <aL>        
17) ncurses/6.4-gcc-13.2.0-4o2yj6n <aL>           
18) hwloc/2.9.1-gcc-13.2.0-gzvfolk <aL>           
19) intel-tbb/2021.9.0-gcc-13.2.0-6nwk3ml <aL>    
20) intel-oneapi-mkl/2023.2.0-gcc-13.2.0-ohvyk7g  

Key:
<module-tag>  <aL>=auto-loaded  
/central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF
Thu Apr 17 13:21:30 PDT 2025
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
hpc-90-11.cm.cluster
--------------------------------------------------------------------------
WARNING: There was an error initializing an OpenFabrics device.

  Local host:   hpc-90-11
  Local device: mlx5_0
--------------------------------------------------------------------------
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 

Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:21:33 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      #INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    #INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************

Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0

PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3

'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
[INPUT] num. electrons = 171
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    :
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom

nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   [INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   [INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

CPU time:         0.95
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
nuclear repulsion = 1868.38919656687
number of shells = 84
PySCF version 2.5.0
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
nuclear repulsion = 1868.38919656687
number of shells = 84
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   N_elec (88, 83), N_ao 198
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
CPU time:         0.94
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
CPU time:         0.94
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

 else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
ecp = {}
CPU time:         0.95
N_elec (88, 83), N_ao 198
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

N_elec (88, 83), N_ao 198
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

N_elec (88, 83), N_ao 198
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
number of NR pGTOs = 449
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
ecp = {}
CPU time:         0.94
number of NR pGTOs = 449
number of NR cGTOs = 198
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[CONFIG] conf_file None
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] charge = -3
[CONFIG] conf_file None
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_62/get_JM.py ****
N_elec (88, 83), N_ao 198
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
System: uname_result(system='Linux', node='hpc-90-11.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:21:33 2025
PySCF version 2.5.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

CPU time:         0.95
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
N_elec (88, 83), N_ao 198
**** MO energy ****
MO #1   energy= -1986.50530561564  occ= 1
MO #2   energy= -1986.50519228166  occ= 1
MO #3   energy= -335.744450857333  occ= 1
MO #4   energy= -335.743992694272  occ= 1
MO #5   energy= -318.560716315452  occ= 1
MO #6   energy= -318.560458167224  occ= 1
MO #7   energy= -288.739733345304  occ= 1
MO #8   energy= -288.739364886552  occ= 1
MO #9   energy= -288.731600853831  occ= 1
MO #10  energy= -288.731477215625  occ= 1
MO #11  energy= -105.08354659815   occ= 1
MO #12  energy= -105.08354298704   occ= 1
MO #13  energy= -105.083410118262  occ= 1
MO #14  energy= -105.083406508396  occ= 1
MO #15  energy= -105.082235980469  occ= 1
MO #16  energy= -105.082214332834  occ= 1
MO #17  energy= -105.082104734442  occ= 1
MO #18  energy= -105.082083067843  occ= 1
MO #19  energy= -105.081554446712  occ= 1
MO #20  energy= -105.081534477902  occ= 1
MO #21  energy= -105.081426494834  occ= 1
MO #22  energy= -105.081406508705  occ= 1
MO #23  energy= -77.076790643062   occ= 1
MO #24  energy= -76.9572704070633  occ= 1
MO #25  energy= -69.5782772593032  occ= 1
MO #26  energy= -69.5597052786664  occ= 1
MO #27  energy= -63.2150017585289  occ= 1
MO #28  energy= -63.2058269251409  occ= 1
MO #29  energy= -63.1306505458288  occ= 1
MO #30  energy= -63.0453057679727  occ= 1
MO #31  energy= -50.7717381359379  occ= 1
MO #32  energy= -50.7676978349481  occ= 1
MO #33  energy= -50.7600221728554  occ= 1
MO #34  energy= -50.7375828339013  occ= 1
MO #35  energy= -49.1960988563606  occ= 1
MO #36  energy= -49.1796964252697  occ= 1
MO #37  energy= -49.1678859804899  occ= 1
MO #38  energy= -49.0956484321751  occ= 1
MO #39  energy= -49.0500877899805  occ= 1
MO #40  energy= -48.9961104208638  occ= 1
MO #41  energy= -16.556121115151   occ= 1
MO #42  energy= -16.2412068737447  occ= 1
MO #43  energy= -13.4592767647091  occ= 1
MO #44  energy= -13.4141231266294  occ= 1
MO #45  energy= -12.0553776290352  occ= 1
MO #46  energy= -12.0154170750093  occ= 1
MO #47  energy= -11.8192091884379  occ= 1
MO #48  energy= -11.6603891660516  occ= 1
MO #49  energy= -10.4906072690706  occ= 1
MO #50  energy= -10.4906055612574  occ= 1
MO #51  energy= -10.490458294312   occ= 1
MO #52  energy= -10.4904565890227  occ= 1
MO #53  energy= -10.4892647483799  occ= 1
MO #54  energy= -10.4892433506849  occ= 1
MO #55  energy= -10.4891211089767  occ= 1
MO #56  energy= -10.4890996918622  occ= 1
MO #57  energy= -10.4885663070207  occ= 1
MO #58  energy= -10.4885466081403  occ= 1
MO #59  energy= -10.4884268170772  occ= 1
MO #60  energy= -10.488407100418   occ= 1
MO #61  energy= -7.94775146232173  occ= 1
MO #62  energy= -7.94774975057213  occ= 1
MO #63  energy= -7.94764856602459  occ= 1
MO #64  energy= -7.94764684878106  occ= 1
MO #65  energy= -7.94642853298188  occ= 1
MO #66  energy= -7.94640709685646  occ= 1
MO #67  energy= -7.94629704811871  occ= 1
MO #68  energy= -7.9462755933054   occ= 1
MO #69  energy= -7.94574018267255  occ= 1
MO #70  energy= -7.94572045013099  occ= 1
MO #71  energy= -7.94560120442846  occ= 1
MO #72  energy= -7.94558145221016  occ= 1
MO #73  energy= -7.87988140129094  occ= 1
MO #74  energy= -7.87987883932447  occ= 1
MO #75  energy= -7.87962062874592  occ= 1
MO #76  energy= -7.87961802829051  occ= 1
MO #77  energy= -7.87896329155142  occ= 1
MO #78  energy= -7.87895821176402  occ= 1
MO #79  energy= -7.87886253625782  occ= 1
MO #80  energy= -7.87885743626582  occ= 1
MO #81  energy= -7.87853895059423  occ= 1
MO #82  energy= -7.87851743158521  occ= 1
MO #83  energy= -7.87827553540499  occ= 1
MO #84  energy= -7.87825397713424  occ= 1
MO #85  energy= -7.87783905626274  occ= 1
MO #86  energy= -7.87781922697087  occ= 1
MO #87  energy= -7.87761311425249  occ= 1
MO #88  energy= -7.87759125046999  occ= 1
MO #89  energy= -7.8775766596941   occ= 1
MO #90  energy= -7.87755765936157  occ= 1
MO #91  energy= -7.87755310120471  occ= 1
MO #92  energy= -7.87753177259255  occ= 1
MO #93  energy= -7.87689417531526  occ= 1
MO #94  energy= -7.87688956076211  occ= 1
MO #95  energy= -7.87687383141034  occ= 1
MO #96  energy= -7.87686921016306  occ= 1
MO #97  energy= -7.1412512909598   occ= 1
MO #98  energy= -7.14008775526675  occ= 1
MO #99  energy= -7.11087210027482  occ= 1
MO #100 energy= -7.04917792819656  occ= 1
MO #101 energy= -6.81799442778709  occ= 1
MO #102 energy= -6.77088694617633  occ= 1
MO #103 energy= -6.61046833281193  occ= 1
MO #104 energy= -6.39851474180787  occ= 1
MO #105 energy= -6.33424124403992  occ= 1
MO #106 energy= -6.23758304886744  occ= 1
MO #107 energy= -2.38435182286431  occ= 1
MO #108 energy= -2.26769598730044  occ= 1
MO #109 energy= -1.4154441773779   occ= 1
MO #110 energy= -1.41180986291607  occ= 1
MO #111 energy= -1.22103895229451  occ= 1
MO #112 energy= -1.21522385338883  occ= 1
MO #113 energy= -1.17900083588722  occ= 1
MO #114 energy= -1.13416038691321  occ= 1
MO #115 energy= -0.953140794868985 occ= 1
MO #116 energy= -0.952570834513469 occ= 1
MO #117 energy= -0.944829947837335 occ= 1
MO #118 energy= -0.943918735511008 occ= 1
MO #119 energy= -0.943560652409762 occ= 1
MO #120 energy= -0.94266029815474  occ= 1
MO #121 energy= -0.941974469286865 occ= 1
MO #122 energy= -0.941622620504824 occ= 1
MO #123 energy= -0.937448018562845 occ= 1
MO #124 energy= -0.936807227856874 occ= 1
MO #125 energy= -0.936104384609314 occ= 1
MO #126 energy= -0.933144057569633 occ= 1
MO #127 energy= -0.859029771126032 occ= 1
MO #128 energy= -0.854519463510361 occ= 1
MO #129 energy= -0.837705610673117 occ= 1
MO #130 energy= -0.815554851315514 occ= 1
MO #131 energy= -0.780970244499289 occ= 1
MO #132 energy= -0.777671111061717 occ= 1
MO #133 energy= -0.728024734444894 occ= 1
MO #134 energy= -0.631654431376252 occ= 1
MO #135 energy= -0.617516368623022 occ= 1
MO #136 energy= -0.406353057839703 occ= 1
MO #137 energy= -0.405119769822705 occ= 1
MO #138 energy= -0.382835649234956 occ= 1
MO #139 energy= -0.381977367734024 occ= 1
MO #140 energy= -0.380659326054946 occ= 1
MO #141 energy= -0.380179258076884 occ= 1
MO #142 energy= -0.372295816029138 occ= 1
MO #143 energy= -0.371907007166619 occ= 1
MO #144 energy= -0.371237884539613 occ= 1
MO #145 energy= -0.371163555215196 occ= 1
MO #146 energy= -0.370522377508311 occ= 1
MO #147 energy= -0.370397523202545 occ= 1
MO #148 energy= -0.368658408309738 occ= 1
MO #149 energy= -0.368454087156263 occ= 1
MO #150 energy= -0.368343585199385 occ= 1
MO #151 energy= -0.368095625475241 occ= 1
MO #152 energy= -0.367699096868109 occ= 1
MO #153 energy= -0.366309637056984 occ= 1
MO #154 energy= -0.34317999433285  occ= 1
MO #155 energy= -0.342313491427412 occ= 1
MO #156 energy= -0.341339272094638 occ= 1
MO #157 energy= -0.34093905923644  occ= 1
MO #158 energy= -0.340597138397617 occ= 1
MO #159 energy= -0.340295917383355 occ= 1
MO #160 energy= -0.338189081181701 occ= 1
MO #161 energy= -0.338068923447338 occ= 1
MO #162 energy= -0.335433209807904 occ= 1
MO #163 energy= -0.334878095191723 occ= 1
MO #164 energy= -0.334545671918923 occ= 1
MO #165 energy= -0.333881631809103 occ= 1
MO #166 energy= -0.327146949327413 occ= 1
MO #167 energy= -0.326904664724271 occ= 1
MO #168 energy= -0.324531527757583 occ= 1
MO #169 energy= -0.324138861745545 occ= 1
MO #170 energy= -0.323826660713439 occ= 1
MO #171 energy= -0.323579821827454 occ= 1
MO #172 energy= 0.122829514771427  occ= 0
MO #173 energy= 0.122908409287422  occ= 0
MO #174 energy= 0.123029526086458  occ= 0
MO #175 energy= 0.123059523191184  occ= 0
MO #176 energy= 0.123147944737698  occ= 0
MO #177 energy= 0.123228865958179  occ= 0
MO #178 energy= 0.129499715608922  occ= 0
MO #179 energy= 0.129505697995609  occ= 0
MO #180 energy= 0.129801585475282  occ= 0
MO #181 energy= 0.129808146681639  occ= 0
MO #182 energy= 0.129982148496686  occ= 0
MO #183 energy= 0.129985192457492  occ= 0
MO #184 energy= 0.13344429817444   occ= 0
MO #185 energy= 0.133549501078486  occ= 0
MO #186 energy= 0.153345091508331  occ= 0
MO #187 energy= 0.153778096983346  occ= 0
MO #188 energy= 0.15397034728274   occ= 0
MO #189 energy= 0.154280142396375  occ= 0
MO #190 energy= 0.204962555880628  occ= 0
MO #191 energy= 0.207616552395461  occ= 0
MO #192 energy= 0.215868532761546  occ= 0
MO #193 energy= 0.224659455222168  occ= 0
MO #194 energy= 0.2305268800393    occ= 0
MO #195 energy= 0.238087540297518  occ= 0
MO #196 energy= 0.292025769932638  occ= 0
MO #197 energy= 0.296842935748134  occ= 0
MO #198 energy= 0.297097251376749  occ= 0
MO #199 energy= 0.298282159713848  occ= 0
MO #200 energy= 0.298500302144348  occ= 0
MO #201 energy= 0.298724386746407  occ= 0
MO #202 energy= 0.29888705689358   occ= 0
MO #203 energy= 0.301736649995312  occ= 0
MO #204 energy= 0.310267131691821  occ= 0
MO #205 energy= 0.312300411372576  occ= 0
MO #206 energy= 0.320291285257204  occ= 0
MO #207 energy= 0.323108290460925  occ= 0
MO #208 energy= 0.337100479782482  occ= 0
MO #209 energy= 0.337373178526161  occ= 0
MO #210 energy= 0.338416555468834  occ= 0
MO #211 energy= 0.339471863688335  occ= 0
MO #212 energy= 0.340523810690701  occ= 0
MO #213 energy= 0.341651504231541  occ= 0
MO #214 energy= 0.343312438812431  occ= 0
MO #215 energy= 0.344291565823604  occ= 0
MO #216 energy= 0.348596530195142  occ= 0
MO #217 energy= 0.351356110716586  occ= 0
MO #218 energy= 0.40418062529256   occ= 0
MO #219 energy= 0.411477892966622  occ= 0
MO #220 energy= 0.436493684447055  occ= 0
MO #221 energy= 0.442945317689751  occ= 0
MO #222 energy= 0.467303890368794  occ= 0
MO #223 energy= 0.47342481674608   occ= 0
MO #224 energy= 0.485395672067179  occ= 0
MO #225 energy= 0.493906053474346  occ= 0
MO #226 energy= 0.49718350837979   occ= 0
MO #227 energy= 0.499602696404647  occ= 0
MO #228 energy= 0.515272009614915  occ= 0
MO #229 energy= 0.521205778685063  occ= 0
MO #230 energy= 0.543954931523968  occ= 0
MO #231 energy= 0.547160769638278  occ= 0
MO #232 energy= 0.587656323678821  occ= 0
MO #233 energy= 0.606224938591662  occ= 0
MO #234 energy= 0.607518998137153  occ= 0
MO #235 energy= 0.608144330585269  occ= 0
MO #236 energy= 0.612420213518253  occ= 0
MO #237 energy= 0.618896479898997  occ= 0
MO #238 energy= 0.626629520125549  occ= 0
MO #239 energy= 0.629189531727193  occ= 0
MO #240 energy= 0.631190671200805  occ= 0
MO #241 energy= 0.635762745276765  occ= 0
MO #242 energy= 0.660953176678296  occ= 0
MO #243 energy= 0.675173080321163  occ= 0
MO #244 energy= 0.686221240297841  occ= 0
MO #245 energy= 0.742754286308772  occ= 0
MO #246 energy= 0.745364771091277  occ= 0
MO #247 energy= 0.748439742691885  occ= 0
MO #248 energy= 0.749979565247711  occ= 0
MO #249 energy= 0.770613398259093  occ= 0
MO #250 energy= 0.771055778685666  occ= 0
MO #251 energy= 0.77334809448355   occ= 0
MO #252 energy= 0.775661884978603  occ= 0
MO #253 energy= 0.777160978280017  occ= 0
MO #254 energy= 0.777268521036918  occ= 0
MO #255 energy= 0.777674217402247  occ= 0
MO #256 energy= 0.777722959112171  occ= 0
MO #257 energy= 0.780530437939086  occ= 0
MO #258 energy= 0.780591883869417  occ= 0
MO #259 energy= 0.783428637293427  occ= 0
MO #260 energy= 0.795099358854953  occ= 0
MO #261 energy= 0.801281754466442  occ= 0
MO #262 energy= 0.801640174523252  occ= 0
MO #263 energy= 0.803174005926773  occ= 0
MO #264 energy= 0.80481723383462   occ= 0
MO #265 energy= 0.805274624918125  occ= 0
MO #266 energy= 0.805724295881964  occ= 0
MO #267 energy= 0.80642696138832   occ= 0
MO #268 energy= 0.812009876037333  occ= 0
MO #269 energy= 0.867198112023948  occ= 0
MO #270 energy= 0.867291920025943  occ= 0
MO #271 energy= 0.869915557992223  occ= 0
MO #272 energy= 0.870076870787005  occ= 0
MO #273 energy= 0.870398250694968  occ= 0
MO #274 energy= 0.870496107884367  occ= 0
MO #275 energy= 0.933098951394954  occ= 0
MO #276 energy= 0.933707767324843  occ= 0
MO #277 energy= 0.934111947210658  occ= 0
MO #278 energy= 0.934327880259716  occ= 0
MO #279 energy= 0.937515615770561  occ= 0
MO #280 energy= 0.938178080727769  occ= 0
MO #281 energy= 1.01768833372893   occ= 0
MO #282 energy= 1.01861895228895   occ= 0
MO #283 energy= 1.02068192020005   occ= 0
MO #284 energy= 1.02129876653737   occ= 0
MO #285 energy= 1.02394157373001   occ= 0
MO #286 energy= 1.02510776111881   occ= 0
MO #287 energy= 1.02963761590967   occ= 0
MO #288 energy= 1.04082758454307   occ= 0
MO #289 energy= 1.04314389888153   occ= 0
MO #290 energy= 1.04476727449397   occ= 0
MO #291 energy= 1.09197974906679   occ= 0
MO #292 energy= 1.09203558296866   occ= 0
MO #293 energy= 1.09432084326205   occ= 0
MO #294 energy= 1.09447504066245   occ= 0
MO #295 energy= 1.09473046540513   occ= 0
MO #296 energy= 1.09519491712955   occ= 0
MO #297 energy= 1.10795111881691   occ= 0
MO #298 energy= 1.11250147074901   occ= 0
MO #299 energy= 1.12189272808846   occ= 0
MO #300 energy= 1.12487160144138   occ= 0
MO #301 energy= 1.32560836806963   occ= 0
MO #302 energy= 1.33044080681452   occ= 0
MO #303 energy= 1.37039309215431   occ= 0
MO #304 energy= 1.38317264746539   occ= 0
MO #305 energy= 1.52883567817874   occ= 0
MO #306 energy= 1.53677041067043   occ= 0
MO #307 energy= 1.55436958084513   occ= 0
MO #308 energy= 1.58937385266591   occ= 0
MO #309 energy= 1.59882374006459   occ= 0
MO #310 energy= 1.60391295479533   occ= 0
MO #311 energy= 1.60581608530296   occ= 0
MO #312 energy= 1.61215702523413   occ= 0
MO #313 energy= 1.62146257943623   occ= 0
MO #314 energy= 1.6229932269964    occ= 0
MO #315 energy= 1.64019465219791   occ= 0
MO #316 energy= 1.68302581972614   occ= 0
MO #317 energy= 1.7082429200247    occ= 0
MO #318 energy= 1.71042092009302   occ= 0
MO #319 energy= 1.85522564903545   occ= 0
MO #320 energy= 1.86286850933539   occ= 0
MO #321 energy= 1.88054621529992   occ= 0
MO #322 energy= 1.91895675552619   occ= 0
MO #323 energy= 1.92567619839551   occ= 0
MO #324 energy= 1.93132684332789   occ= 0
MO #325 energy= 2.64987332902654   occ= 0
MO #326 energy= 2.66093797975284   occ= 0
MO #327 energy= 2.68032866891309   occ= 0
MO #328 energy= 2.70751437610372   occ= 0
MO #329 energy= 2.74220692472017   occ= 0
MO #330 energy= 2.76521552663164   occ= 0
MO #331 energy= 2.83191046522135   occ= 0
MO #332 energy= 2.8511874075419    occ= 0
MO #333 energy= 2.89781266035041   occ= 0
MO #334 energy= 2.91478978417695   occ= 0
MO #335 energy= 4.40984591223378   occ= 0
MO #336 energy= 4.46557917890658   occ= 0
MO #337 energy= 5.73107768157483   occ= 0
MO #338 energy= 5.74303392812365   occ= 0
MO #339 energy= 6.24319171706455   occ= 0
MO #340 energy= 6.2532210454487    occ= 0
MO #341 energy= 6.28285143905523   occ= 0
MO #342 energy= 6.34081594875032   occ= 0
MO #343 energy= 11.4063336076513   occ= 0
MO #344 energy= 11.4221324475077   occ= 0
MO #345 energy= 11.446904209763    occ= 0
MO #346 energy= 11.4842813083111   occ= 0
MO #347 energy= 11.7325177383717   occ= 0
MO #348 energy= 11.7615598939398   occ= 0
MO #349 energy= 11.7821110473942   occ= 0
MO #350 energy= 11.8053337496147   occ= 0
MO #351 energy= 11.8661493164472   occ= 0
MO #352 energy= 11.9203625699598   occ= 0
MO #353 energy= 16.7876256716579   occ= 0
MO #354 energy= 16.8806065150379   occ= 0
MO #355 energy= 27.9148681907563   occ= 0
MO #356 energy= 27.9373239625103   occ= 0
MO #357 energy= 31.0817291694432   occ= 0
MO #358 energy= 31.1142374294778   occ= 0
MO #359 energy= 31.1330141498425   occ= 0
MO #360 energy= 31.2151313384468   occ= 0
MO #361 energy= 60.4328068643924   occ= 0
MO #362 energy= 60.4401117527158   occ= 0
MO #363 energy= 60.4660033533015   occ= 0
MO #364 energy= 60.4957259726188   occ= 0
MO #365 energy= 62.6199145962314   occ= 0
MO #366 energy= 62.6383979591442   occ= 0
MO #367 energy= 62.6560930989968   occ= 0
MO #368 energy= 62.6700427994915   occ= 0
MO #369 energy= 62.7011238500263   occ= 0
MO #370 energy= 62.7487943905262   occ= 0
MO #371 energy= 71.9741266358354   occ= 0
MO #372 energy= 72.0425138237505   occ= 0
MO #373 energy= 150.734081543692   occ= 0
MO #374 energy= 150.743410130505   occ= 0
MO #375 energy= 165.183492138644   occ= 0
MO #376 energy= 165.201735532455   occ= 0
MO #377 energy= 165.211121722374   occ= 0
MO #378 energy= 165.245595209898   occ= 0
MO #379 energy= 294.470791475369   occ= 0
MO #380 energy= 294.491185764973   occ= 0
MO #381 energy= 690.538365290227   occ= 0
MO #382 energy= 690.539839998267   occ= 0
MO #383 energy= 798.986386843747   occ= 0
MO #384 energy= 798.98889575451    occ= 0
MO #385 energy= 798.99646117948    occ= 0
MO #386 energy= 799.001069088772   occ= 0
MO #387 energy= 1008.64577165734   occ= 0
MO #388 energy= 1008.64979147224   occ= 0
MO #389 energy= 2865.03478083741   occ= 0
MO #390 energy= 2865.0356725007    occ= 0
MO #391 energy= 6964.91702896339   occ= 0
MO #392 energy= 6964.91729352081   occ= 0
MO #393 energy= 14850.4541560626   occ= 0
MO #394 energy= 14850.4542483957   occ= 0
MO #395 energy= 35043.5914457051   occ= 0
MO #396 energy= 35043.5914747907   occ= 0
 ** Mulliken pop alpha/beta on meta-lowdin orthogonal AOs **
 ** Mulliken pop       alpha | beta **
pop of  0 Dy 1s        0.99999 | 0.99999   
pop of  0 Dy 2s        1.00000 | 1.00000   
pop of  0 Dy 3s        1.00000 | 1.00000   
pop of  0 Dy 4s        0.99999 | 0.99999   
pop of  0 Dy 5s        0.99817 | 0.99821   
pop of  0 Dy 6s        0.19729 | 0.19712   
pop of  0 Dy 7s        0.00661 | 0.00656   
pop of  0 Dy 8s        0.00038 | 0.00037   
pop of  0 Dy 9s        0.00024 | 0.00024   
pop of  0 Dy 10s        0.00018 | 0.00017   
pop of  0 Dy 11s        0.00000 | 0.00000   
pop of  0 Dy 12s        0.00001 | 0.00001   
pop of  0 Dy 13s        0.00001 | 0.00001   
pop of  0 Dy 14s        0.00000 | 0.00000   
pop of  0 Dy 15s        0.00000 | 0.00000   
pop of  0 Dy 16s        0.00000 | 0.00000   
pop of  0 Dy 17s        0.00000 | 0.00000   
pop of  0 Dy 18s        0.00000 | 0.00000   
pop of  0 Dy 2px       0.99897 | 0.99897   
pop of  0 Dy 2py       0.99897 | 0.99897   
pop of  0 Dy 2pz       0.99897 | 0.99897   
pop of  0 Dy 3px       0.99875 | 0.99875   
pop of  0 Dy 3py       0.99875 | 0.99875   
pop of  0 Dy 3pz       0.99875 | 0.99875   
pop of  0 Dy 4px       0.99838 | 0.99838   
pop of  0 Dy 4py       0.99838 | 0.99838   
pop of  0 Dy 4pz       0.99838 | 0.99838   
pop of  0 Dy 5px       0.99539 | 0.99545   
pop of  0 Dy 5py       0.99575 | 0.99580   
pop of  0 Dy 5pz       0.99594 | 0.99599   
pop of  0 Dy 6px       0.00705 | 0.00698   
pop of  0 Dy 6py       0.00663 | 0.00658   
pop of  0 Dy 6pz       0.00640 | 0.00635   
pop of  0 Dy 7px       0.00333 | 0.00330   
pop of  0 Dy 7py       0.00314 | 0.00311   
pop of  0 Dy 7pz       0.00303 | 0.00301   
pop of  0 Dy 8px       0.00160 | 0.00160   
pop of  0 Dy 8py       0.00156 | 0.00155   
pop of  0 Dy 8pz       0.00154 | 0.00153   
pop of  0 Dy 9px       0.00070 | 0.00069   
pop of  0 Dy 9py       0.00069 | 0.00069   
pop of  0 Dy 9pz       0.00069 | 0.00068   
pop of  0 Dy 10px       0.00070 | 0.00070   
pop of  0 Dy 10py       0.00071 | 0.00071   
pop of  0 Dy 10pz       0.00071 | 0.00071   
pop of  0 Dy 11px       0.00067 | 0.00067   
pop of  0 Dy 11py       0.00068 | 0.00068   
pop of  0 Dy 11pz       0.00068 | 0.00068   
pop of  0 Dy 12px       0.00059 | 0.00059   
pop of  0 Dy 12py       0.00059 | 0.00059   
pop of  0 Dy 12pz       0.00059 | 0.00059   
pop of  0 Dy 13px       0.00107 | 0.00107   
pop of  0 Dy 13py       0.00107 | 0.00107   
pop of  0 Dy 13pz       0.00107 | 0.00107   
pop of  0 Dy 3dxy      0.99991 | 0.99991   
pop of  0 Dy 3dyz      0.99991 | 0.99991   
pop of  0 Dy 3dz^2     0.99991 | 0.99991   
pop of  0 Dy 3dxz      0.99991 | 0.99991   
pop of  0 Dy 3dx2-y2    0.99991 | 0.99991   
pop of  0 Dy 4dxy      0.99972 | 0.99972   
pop of  0 Dy 4dyz      0.99974 | 0.99974   
pop of  0 Dy 4dz^2     0.99974 | 0.99974   
pop of  0 Dy 4dxz      0.99973 | 0.99973   
pop of  0 Dy 4dx2-y2    0.99972 | 0.99972   
pop of  0 Dy 5dxy      0.01423 | 0.01416   
pop of  0 Dy 5dyz      0.01369 | 0.01365   
pop of  0 Dy 5dz^2     0.03376 | 0.03361   
pop of  0 Dy 5dxz      0.01396 | 0.01391   
pop of  0 Dy 5dx2-y2    0.03483 | 0.03463   
pop of  0 Dy 6dxy      0.00165 | 0.00166   
pop of  0 Dy 6dyz      0.00164 | 0.00164   
pop of  0 Dy 6dz^2     0.00044 | 0.00043   
pop of  0 Dy 6dxz      0.00163 | 0.00163   
pop of  0 Dy 6dx2-y2    0.00047 | 0.00047   
pop of  0 Dy 7dxy      0.00014 | 0.00014   
pop of  0 Dy 7dyz      0.00014 | 0.00014   
pop of  0 Dy 7dz^2     0.00243 | 0.00242   
pop of  0 Dy 7dxz      0.00014 | 0.00014   
pop of  0 Dy 7dx2-y2    0.00249 | 0.00249   
pop of  0 Dy 8dxy      0.00004 | 0.00004   
pop of  0 Dy 8dyz      0.00004 | 0.00004   
pop of  0 Dy 8dz^2     0.00095 | 0.00095   
pop of  0 Dy 8dxz      0.00004 | 0.00004   
pop of  0 Dy 8dx2-y2    0.00097 | 0.00097   
pop of  0 Dy 9dxy      0.00009 | 0.00009   
pop of  0 Dy 9dyz      0.00009 | 0.00009   
pop of  0 Dy 9dz^2     0.00018 | 0.00018   
pop of  0 Dy 9dxz      0.00009 | 0.00009   
pop of  0 Dy 9dx2-y2    0.00017 | 0.00017   
pop of  0 Dy 10dxy      0.00015 | 0.00014   
pop of  0 Dy 10dyz      0.00014 | 0.00014   
pop of  0 Dy 10dz^2     0.00014 | 0.00014   
pop of  0 Dy 10dxz      0.00014 | 0.00014   
pop of  0 Dy 10dx2-y2    0.00014 | 0.00014   
pop of  0 Dy 11dxy      0.00018 | 0.00018   
pop of  0 Dy 11dyz      0.00017 | 0.00017   
pop of  0 Dy 11dz^2     0.00002 | 0.00002   
pop of  0 Dy 11dxz      0.00017 | 0.00017   
pop of  0 Dy 11dx2-y2    0.00002 | 0.00002   
pop of  0 Dy 4f-3      0.59671 | 0.57150   
pop of  0 Dy 4f-2      0.64529 | 0.62319   
pop of  0 Dy 4f-1      0.71545 | 0.70553   
pop of  0 Dy 4f+0      0.66291 | 0.64334   
pop of  0 Dy 4f+1      0.67835 | 0.66938   
pop of  0 Dy 4f+2      0.72237 | 0.70914   
pop of  0 Dy 4f+3      0.54284 | 0.51076   
pop of  0 Dy 5f-3      0.00155 | 0.00151   
pop of  0 Dy 5f-2      0.00077 | 0.00074   
pop of  0 Dy 5f-1      0.00107 | 0.00104   
pop of  0 Dy 5f+0      0.00156 | 0.00153   
pop of  0 Dy 5f+1      0.00122 | 0.00119   
pop of  0 Dy 5f+2      0.00094 | 0.00090   
pop of  0 Dy 5f+3      0.00159 | 0.00154   
pop of  0 Dy 6f-3      0.00197 | 0.00197   
pop of  0 Dy 6f-2      0.00013 | 0.00012   
pop of  0 Dy 6f-1      0.00173 | 0.00172   
pop of  0 Dy 6f+0      0.00216 | 0.00216   
pop of  0 Dy 6f+1      0.00177 | 0.00177   
pop of  0 Dy 6f+2      0.00149 | 0.00149   
pop of  0 Dy 6f+3      0.00200 | 0.00200   
pop of  1 Cl 1s        1.00000 | 1.00000   
pop of  1 Cl 2s        1.00000 | 1.00000   
pop of  1 Cl 3s        0.98076 | 0.98076   
pop of  1 Cl 4s        0.00147 | 0.00147   
pop of  1 Cl 2px       1.00000 | 1.00000   
pop of  1 Cl 2py       1.00000 | 1.00000   
pop of  1 Cl 2pz       1.00000 | 1.00000   
pop of  1 Cl 3px       0.96609 | 0.96618   
pop of  1 Cl 3py       0.99252 | 0.99253   
pop of  1 Cl 3pz       0.99264 | 0.99265   
pop of  1 Cl 4px       0.00190 | 0.00189   
pop of  1 Cl 4py       0.00167 | 0.00167   
pop of  1 Cl 4pz       0.00166 | 0.00166   
pop of  2 Cl 1s        1.00000 | 1.00000   
pop of  2 Cl 2s        1.00000 | 1.00000   
pop of  2 Cl 3s        0.98076 | 0.98076   
pop of  2 Cl 4s        0.00147 | 0.00147   
pop of  2 Cl 2px       1.00000 | 1.00000   
pop of  2 Cl 2py       1.00000 | 1.00000   
pop of  2 Cl 2pz       1.00000 | 1.00000   
pop of  2 Cl 3px       0.96609 | 0.96618   
pop of  2 Cl 3py       0.99252 | 0.99253   
pop of  2 Cl 3pz       0.99265 | 0.99265   
pop of  2 Cl 4px       0.00190 | 0.00189   
pop of  2 Cl 4py       0.00167 | 0.00167   
pop of  2 Cl 4pz       0.00166 | 0.00166   
pop of  3 Cl 1s        1.00000 | 1.00000   
pop of  3 Cl 2s        1.00000 | 1.00000   
pop of  3 Cl 3s        0.98078 | 0.98078   
pop of  3 Cl 4s        0.00144 | 0.00143   
pop of  3 Cl 2px       1.00000 | 1.00000   
pop of  3 Cl 2py       1.00000 | 1.00000   
pop of  3 Cl 2pz       1.00000 | 1.00000   
pop of  3 Cl 3px       0.99242 | 0.99242   
pop of  3 Cl 3py       0.96659 | 0.96668   
pop of  3 Cl 3pz       0.99273 | 0.99274   
pop of  3 Cl 4px       0.00170 | 0.00170   
pop of  3 Cl 4py       0.00189 | 0.00188   
pop of  3 Cl 4pz       0.00168 | 0.00168   
pop of  4 Cl 1s        1.00000 | 1.00000   
pop of  4 Cl 2s        1.00000 | 1.00000   
pop of  4 Cl 3s        0.98078 | 0.98078   
pop of  4 Cl 4s        0.00144 | 0.00143   
pop of  4 Cl 2px       1.00000 | 1.00000   
pop of  4 Cl 2py       1.00000 | 1.00000   
pop of  4 Cl 2pz       1.00000 | 1.00000   
pop of  4 Cl 3px       0.99242 | 0.99242   
pop of  4 Cl 3py       0.96659 | 0.96668   
pop of  4 Cl 3pz       0.99273 | 0.99274   
pop of  4 Cl 4px       0.00170 | 0.00170   
pop of  4 Cl 4py       0.00189 | 0.00188   
pop of  4 Cl 4pz       0.00168 | 0.00168   
pop of  5 Cl 1s        1.00000 | 1.00000   
pop of  5 Cl 2s        1.00000 | 1.00000   
pop of  5 Cl 3s        0.98077 | 0.98078   
pop of  5 Cl 4s        0.00142 | 0.00142   
pop of  5 Cl 2px       1.00000 | 1.00000   
pop of  5 Cl 2py       1.00000 | 1.00000   
pop of  5 Cl 2pz       1.00000 | 1.00000   
pop of  5 Cl 3px       0.99252 | 0.99253   
pop of  5 Cl 3py       0.99267 | 0.99268   
pop of  5 Cl 3pz       0.96667 | 0.96675   
pop of  5 Cl 4px       0.00170 | 0.00170   
pop of  5 Cl 4py       0.00169 | 0.00169   
pop of  5 Cl 4pz       0.00188 | 0.00187   
pop of  6 Cl 1s        1.00000 | 1.00000   
pop of  6 Cl 2s        1.00000 | 1.00000   
pop of  6 Cl 3s        0.98077 | 0.98078   
pop of  6 Cl 4s        0.00142 | 0.00142   
pop of  6 Cl 2px       1.00000 | 1.00000   
pop of  6 Cl 2py       1.00000 | 1.00000   
pop of  6 Cl 2pz       1.00000 | 1.00000   
pop of  6 Cl 3px       0.99252 | 0.99253   
pop of  6 Cl 3py       0.99267 | 0.99267   
pop of  6 Cl 3pz       0.96667 | 0.96675   
pop of  6 Cl 4px       0.00170 | 0.00170   
pop of  6 Cl 4py       0.00169 | 0.00169   
pop of  6 Cl 4pz       0.00188 | 0.00187   
In total            85.56580 | 85.43420  
 ** Mulliken atomic charges   ( Nelec_alpha | Nelec_beta ) **
charge of  0Dy =      2.26953  (    31.93130     31.79916 )
charge of  1Cl =     -0.87751  (     8.93871      8.93880 )
charge of  2Cl =     -0.87751  (     8.93871      8.93880 )
charge of  3Cl =     -0.87852  (     8.93921      8.93931 )
charge of  4Cl =     -0.87853  (     8.93922      8.93931 )
charge of  5Cl =     -0.87874  (     8.93933      8.93942 )
charge of  6Cl =     -0.87873  (     8.93932      8.93941 )
(3, 198, 198) 198
S vector [-2.0401+0.j  1.2299-0.j  0.0658-0.j]
(3, 198, 198) 198
L vector [-4.3951-0.j  2.6127-0.j  0.1373+0.j]
(3, 198, 198) 198
J vector [-6.4352-0.j  3.8427-0.j  0.2031-0.j]
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!
LO diff from identity 0.003969852403580924


WARN: LO is not orthonormal!

WARN: LO is not orthonormal!

WARN: LO is not orthonormal!




WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

ao_index [ 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317]
ao_labels ['0 Dy 4f-3  ' '0 Dy 4f-2  ' '0 Dy 4f-1  ' '0 Dy 4f+0  ' '0 Dy 4f+1  ' '0 Dy 4f+2  ' '0 Dy 4f+3  ' '0 Dy 5f-3  ' '0 Dy 5f-2  ' '0 Dy 5f-1  ' '0 Dy 5f+0  ' '0 Dy 5f+1  ' '0 Dy 5f+2  ' '0 Dy 5f+3  ' '0 Dy 6f-3  ' '0 Dy 6f-2  ' '0 Dy 6f-1  ' '0 Dy 6f+0  ' '0 Dy 6f+1  ' '0 Dy 6f+2  ' '0 Dy 6f+3  ']
  J     M     c^2  
rank = 0, idx_lst = [ 0 16]
rank = 13, idx_lst = [13]
rank = 8, idx_lst = [ 8 24]
rank = 15, idx_lst = [15]
rank = 9, idx_lst = [ 9 25]
rank = 4, idx_lst = [ 4 20]
rank = 3, idx_lst = [ 3 19]
rank = 1, idx_lst = [ 1 17]
rank = 14, idx_lst = [14]
rank = 11, idx_lst = [11 27]
rank = 6, idx_lst = [ 6 22]
rank = 5, idx_lst = [ 5 21]
rank = 12, idx_lst = [12 28]
rank = 10, idx_lst = [10 26]
rank = 7, idx_lst = [ 7 23]
rank = 2, idx_lst = [ 2 18]
[hpc-90-11.cm.cluster:2317666] 15 more processes have sent help message help-mpi-btl-openib.txt / error in device init
[hpc-90-11.cm.cluster:2317666] Set MCA parameter "orte_base_help_aggregate" to 0 to see all help / error messages
 7.5    7.5    7.5    0.00002   -0.00000
 7.5    7.5    6.5   -0.00010    0.00005
 7.5    7.5    5.5    0.00018   -0.00026
 7.5    7.5    4.5   -0.00007    0.00067
 7.5    7.5    3.5   -0.00049   -0.00107
 7.5    7.5    2.5    0.00142    0.00099
 7.5    7.5    1.5   -0.00220   -0.00016
 7.5    7.5    0.5    0.00219   -0.00110
 7.5    7.5   -0.5   -0.00128    0.00202
 7.5    7.5   -1.5    0.00005   -0.00203
 7.5    7.5   -2.5    0.00074    0.00132
 7.5    7.5   -3.5   -0.00084   -0.00048
 7.5    7.5   -4.5    0.00053    0.00001
 7.5    7.5   -5.5   -0.00020    0.00012
 7.5    7.5   -6.5    0.00004   -0.00007
 7.5    7.5   -7.5   -0.00000    0.00002
 7.5    6.5    6.5    0.00047   -0.00001
 7.5    6.5    5.5   -0.00113    0.00062
 7.5    6.5    4.5    0.00145   -0.00232
 7.5    6.5    3.5   -0.00014    0.00476
 7.5    6.5    2.5   -0.00339   -0.00615
 7.5    6.5    1.5    0.00772    0.00452
 7.5    6.5    0.5   -0.00994    0.00009
 7.5    6.5   -0.5    0.00824   -0.00505
 7.5    6.5   -1.5   -0.00382    0.00730
 7.5    6.5   -2.5   -0.00034   -0.00610
 7.5    6.5   -3.5    0.00218    0.00326
 7.5    6.5   -4.5   -0.00190   -0.00095
 7.5    6.5   -5.5    0.00094   -0.00005
 7.5    6.5   -6.5   -0.00028    0.00017
 7.5    6.5   -7.5    0.00004   -0.00006
 7.5    5.5    5.5    0.00354   -0.00001
 7.5    5.5    4.5   -0.00648    0.00370
 7.5    5.5    3.5    0.00650   -0.01120
 7.5    5.5    2.5    0.00016    0.01908
 7.5    5.5    1.5   -0.01262   -0.02076
 7.5    5.5    0.5    0.02387    0.01257
 7.5    5.5   -0.5   -0.02621    0.00145
 7.5    5.5   -1.5    0.01852   -0.01253
 7.5    5.5   -2.5   -0.00705    0.01504
 7.5    5.5   -3.5   -0.00099   -0.01061
 7.5    5.5   -4.5    0.00334    0.00472
 7.5    5.5   -5.5   -0.00233   -0.00111
 7.5    5.5   -6.5    0.00090   -0.00003
 7.5    5.5   -7.5   -0.00019    0.00009
 7.5    4.5    4.5    0.01575   -0.00002
 7.5    4.5    3.5   -0.02357    0.01378
 7.5    4.5    2.5    0.01953   -0.03513
 7.5    4.5    1.5    0.00157    0.05112
 7.5    4.5    0.5   -0.03067   -0.04779
 7.5    4.5   -0.5    0.04949    0.02452
 7.5    4.5   -1.5   -0.04692    0.00375
 7.5    4.5   -2.5    0.02854   -0.02023
 7.5    4.5   -3.5   -0.00918    0.02046
 7.5    4.5   -4.5   -0.00125   -0.01211
 7.5    4.5   -5.5    0.00313    0.00444
 7.5    4.5   -6.5   -0.00167   -0.00085
 7.5    4.5   -7.5    0.00042    0.00001
 7.5    3.5    3.5    0.04734   -0.00002
 7.5    3.5    2.5   -0.05992    0.03553
 7.5    3.5    1.5    0.04226   -0.07786
 7.5    3.5    0.5    0.00420    0.09825
 7.5    3.5   -0.5   -0.05267   -0.07985
 7.5    3.5   -1.5    0.07348    0.03533
 7.5    3.5   -2.5   -0.06035    0.00538
 7.5    3.5   -3.5    0.03158   -0.02263
 7.5    3.5   -4.5   -0.00869    0.01923
 7.5    3.5   -5.5   -0.00081   -0.00937
 7.5    3.5   -6.5    0.00173    0.00272
 7.5    3.5   -7.5   -0.00062   -0.00042
 7.5    2.5    2.5    0.10250   -0.00002
 7.5    2.5    1.5   -0.11188    0.06686
 7.5    2.5    0.5    0.06834   -0.12748
 7.5    2.5   -0.5    0.00680    0.14053
 7.5    2.5   -1.5   -0.06649   -0.09977
 7.5    2.5   -2.5    0.08040    0.03839
 7.5    2.5   -3.5   -0.05693    0.00499
 7.5    2.5   -4.5    0.02541   -0.01785
 7.5    2.5   -5.5   -0.00601    0.01246
 7.5    2.5   -6.5   -0.00016   -0.00477
 7.5    2.5   -7.5    0.00050    0.00097
 7.5    1.5    1.5    0.16572   -0.00002
 7.5    1.5    0.5   -0.15769    0.09459
 7.5    1.5   -0.5    0.08419   -0.15777
 7.5    1.5   -1.5    0.00755    0.15220
 7.5    1.5   -2.5   -0.06274   -0.09429
 7.5    1.5   -3.5    0.06539    0.03163
 7.5    1.5   -4.5   -0.03936    0.00291
 7.5    1.5   -5.5    0.01469   -0.00970
 7.5    1.5   -6.5   -0.00293    0.00530
 7.5    1.5   -7.5    0.00010   -0.00139
 7.5    0.5    0.5    0.20402   -0.00001
 7.5    0.5   -0.5   -0.17009    0.10209
 7.5    0.5   -1.5    0.07964   -0.14912
 7.5    0.5   -2.5    0.00593    0.12548
 7.5    0.5   -3.5   -0.04417   -0.06738
 7.5    0.5   -4.5    0.03912    0.01967
 7.5    0.5   -5.5   -0.01951    0.00086
 7.5    0.5   -6.5    0.00581   -0.00338
 7.5    0.5   -7.5   -0.00089    0.00127
 7.5   -0.5   -0.5    0.19291   -0.00000
 7.5   -0.5   -1.5   -0.14097    0.08448
 7.5   -0.5   -2.5    0.05782   -0.10756
 7.5   -0.5   -3.5    0.00312    0.07825
 7.5   -0.5   -4.5   -0.02278   -0.03596
 7.5   -0.5   -5.5    0.01669    0.00903
 7.5   -0.5   -6.5   -0.00653   -0.00008
 7.5   -0.5   -7.5    0.00137   -0.00061
 7.5   -1.5   -1.5    0.14000   -0.00002
 7.5   -1.5   -2.5   -0.08932    0.05328
 7.5   -1.5   -3.5    0.03196   -0.05854
 7.5   -1.5   -4.5    0.00092    0.03623
 7.5   -1.5   -5.5   -0.00824   -0.01390
 7.5   -1.5   -6.5    0.00473    0.00292
 7.5   -1.5   -7.5   -0.00127   -0.00015
 7.5   -2.5   -2.5    0.07725   -0.00003
 7.5   -2.5   -3.5   -0.04264    0.02520
 7.5   -2.5   -4.5    0.01318   -0.02346
 7.5   -2.5   -5.5   -0.00002    0.01199
 7.5   -2.5   -6.5   -0.00191   -0.00365
 7.5   -2.5   -7.5    0.00075    0.00057
 7.5   -3.5   -3.5    0.03174   -0.00003
 7.5   -3.5   -4.5   -0.01490    0.00866
 7.5   -3.5   -5.5    0.00391   -0.00661
 7.5   -3.5   -6.5   -0.00013    0.00263
 7.5   -3.5   -7.5   -0.00023   -0.00056
 7.5   -4.5   -4.5    0.00935   -0.00001
 7.5   -4.5   -5.5   -0.00363    0.00204
 7.5   -4.5   -6.5    0.00078   -0.00120
 7.5   -4.5   -7.5   -0.00005    0.00032
 7.5   -5.5   -5.5    0.00185   -0.00000
 7.5   -5.5   -6.5   -0.00057    0.00030
 7.5   -5.5   -7.5    0.00009   -0.00012
 7.5   -6.5   -6.5    0.00022
 7.5   -6.5   -7.5   -0.00005    0.00002
 7.5   -7.5   -7.5    0.00002
triangle [[ 0.    -0.j     -0.0001+0.0001j  0.0002-0.0003j -0.0001+0.0007j -0.0005-0.0011j  0.0014+0.001j  -0.0022-0.0002j  0.0022-0.0011j -0.0013+0.002j   0.    -0.002j   0.0007+0.0013j -0.0008-0.0005j  0.0005+0.j     -0.0002+0.0001j  0.    -0.0001j -0.    +0.j    ]
 [ 0.    +0.j      0.0005-0.j     -0.0011+0.0006j  0.0014-0.0023j -0.0001+0.0048j -0.0034-0.0062j  0.0077+0.0045j -0.0099+0.0001j  0.0082-0.005j  -0.0038+0.0073j -0.0003-0.0061j  0.0022+0.0033j -0.0019-0.0009j  0.0009-0.0001j -0.0003+0.0002j  0.    -0.0001j]
 [ 0.    +0.j      0.    +0.j      0.0035-0.j     -0.0065+0.0037j  0.0065-0.0112j  0.0002+0.0191j -0.0126-0.0208j  0.0239+0.0126j -0.0262+0.0015j  0.0185-0.0125j -0.0071+0.015j  -0.001 -0.0106j  0.0033+0.0047j -0.0023-0.0011j  0.0009-0.j     -0.0002+0.0001j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.0157-0.j     -0.0236+0.0138j  0.0195-0.0351j  0.0016+0.0511j -0.0307-0.0478j  0.0495+0.0245j -0.0469+0.0037j  0.0285-0.0202j -0.0092+0.0205j -0.0012-0.0121j  0.0031+0.0044j -0.0017-0.0008j  0.0004+0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0473-0.j     -0.0599+0.0355j  0.0423-0.0779j  0.0042+0.0983j -0.0527-0.0799j  0.0735+0.0353j -0.0603+0.0054j  0.0316-0.0226j -0.0087+0.0192j -0.0008-0.0094j  0.0017+0.0027j -0.0006-0.0004j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1025-0.j     -0.1119+0.0669j  0.0683-0.1275j  0.0068+0.1405j -0.0665-0.0998j  0.0804+0.0384j -0.0569+0.005j   0.0254-0.0178j -0.006 +0.0125j -0.0002-0.0048j  0.0005+0.001j ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1657-0.j     -0.1577+0.0946j  0.0842-0.1578j  0.0076+0.1522j -0.0627-0.0943j  0.0654+0.0316j -0.0394+0.0029j  0.0147-0.0097j -0.0029+0.0053j  0.0001-0.0014j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.204 -0.j     -0.1701+0.1021j  0.0796-0.1491j  0.0059+0.1255j -0.0442-0.0674j  0.0391+0.0197j -0.0195+0.0009j  0.0058-0.0034j -0.0009+0.0013j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1929-0.j     -0.141 +0.0845j  0.0578-0.1076j  0.0031+0.0783j -0.0228-0.036j   0.0167+0.009j  -0.0065-0.0001j  0.0014-0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.14  -0.j     -0.0893+0.0533j  0.032 -0.0585j  0.0009+0.0362j -0.0082-0.0139j  0.0047+0.0029j -0.0013-0.0002j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0773-0.j     -0.0426+0.0252j  0.0132-0.0235j -0.    +0.012j  -0.0019-0.0037j  0.0007+0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0317-0.j     -0.0149+0.0087j  0.0039-0.0066j -0.0001+0.0026j -0.0002-0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0094-0.j     -0.0036+0.002j   0.0008-0.0012j -0.    +0.0003j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0019-0.j     -0.0006+0.0003j  0.0001-0.0001j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0002+0.j     -0.0001+0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j    ]]
full [[ 0.    +0.j     -0.0001+0.0001j  0.0002-0.0003j -0.0001+0.0007j -0.0005-0.0011j  0.0014+0.001j  -0.0022-0.0002j  0.0022-0.0011j -0.0013+0.002j   0.    -0.002j   0.0007+0.0013j -0.0008-0.0005j  0.0005+0.j     -0.0002+0.0001j  0.    -0.0001j -0.    +0.j    ]
 [-0.0001-0.0001j  0.0005+0.j     -0.0011+0.0006j  0.0014-0.0023j -0.0001+0.0048j -0.0034-0.0062j  0.0077+0.0045j -0.0099+0.0001j  0.0082-0.005j  -0.0038+0.0073j -0.0003-0.0061j  0.0022+0.0033j -0.0019-0.0009j  0.0009-0.0001j -0.0003+0.0002j  0.    -0.0001j]
 [ 0.0002+0.0003j -0.0011-0.0006j  0.0035+0.j     -0.0065+0.0037j  0.0065-0.0112j  0.0002+0.0191j -0.0126-0.0208j  0.0239+0.0126j -0.0262+0.0015j  0.0185-0.0125j -0.0071+0.015j  -0.001 -0.0106j  0.0033+0.0047j -0.0023-0.0011j  0.0009-0.j     -0.0002+0.0001j]
 [-0.0001-0.0007j  0.0014+0.0023j -0.0065-0.0037j  0.0157+0.j     -0.0236+0.0138j  0.0195-0.0351j  0.0016+0.0511j -0.0307-0.0478j  0.0495+0.0245j -0.0469+0.0037j  0.0285-0.0202j -0.0092+0.0205j -0.0012-0.0121j  0.0031+0.0044j -0.0017-0.0008j  0.0004+0.j    ]
 [-0.0005+0.0011j -0.0001-0.0048j  0.0065+0.0112j -0.0236-0.0138j  0.0473+0.j     -0.0599+0.0355j  0.0423-0.0779j  0.0042+0.0983j -0.0527-0.0799j  0.0735+0.0353j -0.0603+0.0054j  0.0316-0.0226j -0.0087+0.0192j -0.0008-0.0094j  0.0017+0.0027j -0.0006-0.0004j]
 [ 0.0014-0.001j  -0.0034+0.0062j  0.0002-0.0191j  0.0195+0.0351j -0.0599-0.0355j  0.1025+0.j     -0.1119+0.0669j  0.0683-0.1275j  0.0068+0.1405j -0.0665-0.0998j  0.0804+0.0384j -0.0569+0.005j   0.0254-0.0178j -0.006 +0.0125j -0.0002-0.0048j  0.0005+0.001j ]
 [-0.0022+0.0002j  0.0077-0.0045j -0.0126+0.0208j  0.0016-0.0511j  0.0423+0.0779j -0.1119-0.0669j  0.1657+0.j     -0.1577+0.0946j  0.0842-0.1578j  0.0076+0.1522j -0.0627-0.0943j  0.0654+0.0316j -0.0394+0.0029j  0.0147-0.0097j -0.0029+0.0053j  0.0001-0.0014j]
 [ 0.0022+0.0011j -0.0099-0.0001j  0.0239-0.0126j -0.0307+0.0478j  0.0042-0.0983j  0.0683+0.1275j -0.1577-0.0946j  0.204 +0.j     -0.1701+0.1021j  0.0796-0.1491j  0.0059+0.1255j -0.0442-0.0674j  0.0391+0.0197j -0.0195+0.0009j  0.0058-0.0034j -0.0009+0.0013j]
 [-0.0013-0.002j   0.0082+0.005j  -0.0262-0.0015j  0.0495-0.0245j -0.0527+0.0799j  0.0068-0.1405j  0.0842+0.1578j -0.1701-0.1021j  0.1929+0.j     -0.141 +0.0845j  0.0578-0.1076j  0.0031+0.0783j -0.0228-0.036j   0.0167+0.009j  -0.0065-0.0001j  0.0014-0.0006j]
 [ 0.    +0.002j  -0.0038-0.0073j  0.0185+0.0125j -0.0469-0.0037j  0.0735-0.0353j -0.0665+0.0998j  0.0076-0.1522j  0.0796+0.1491j -0.141 -0.0845j  0.14  +0.j     -0.0893+0.0533j  0.032 -0.0585j  0.0009+0.0362j -0.0082-0.0139j  0.0047+0.0029j -0.0013-0.0002j]
 [ 0.0007-0.0013j -0.0003+0.0061j -0.0071-0.015j   0.0285+0.0202j -0.0603-0.0054j  0.0804-0.0384j -0.0627+0.0943j  0.0059-0.1255j  0.0578+0.1076j -0.0893-0.0533j  0.0773+0.j     -0.0426+0.0252j  0.0132-0.0235j -0.    +0.012j  -0.0019-0.0037j  0.0007+0.0006j]
 [-0.0008+0.0005j  0.0022-0.0033j -0.001 +0.0106j -0.0092-0.0205j  0.0316+0.0226j -0.0569-0.005j   0.0654-0.0316j -0.0442+0.0674j  0.0031-0.0783j  0.032 +0.0585j -0.0426-0.0252j  0.0317+0.j     -0.0149+0.0087j  0.0039-0.0066j -0.0001+0.0026j -0.0002-0.0006j]
 [ 0.0005-0.j     -0.0019+0.0009j  0.0033-0.0047j -0.0012+0.0121j -0.0087-0.0192j  0.0254+0.0178j -0.0394-0.0029j  0.0391-0.0197j -0.0228+0.036j   0.0009-0.0362j  0.0132+0.0235j -0.0149-0.0087j  0.0094+0.j     -0.0036+0.002j   0.0008-0.0012j -0.    +0.0003j]
 [-0.0002-0.0001j  0.0009+0.0001j -0.0023+0.0011j  0.0031-0.0044j -0.0008+0.0094j -0.006 -0.0125j  0.0147+0.0097j -0.0195-0.0009j  0.0167-0.009j  -0.0082+0.0139j -0.    -0.012j   0.0039+0.0066j -0.0036-0.002j   0.0019+0.j     -0.0006+0.0003j  0.0001-0.0001j]
 [ 0.    +0.0001j -0.0003-0.0002j  0.0009+0.j     -0.0017+0.0008j  0.0017-0.0027j -0.0002+0.0048j -0.0029-0.0053j  0.0058+0.0034j -0.0065+0.0001j  0.0047-0.0029j -0.0019+0.0037j -0.0001-0.0026j  0.0008+0.0012j -0.0006-0.0003j  0.0002+0.j     -0.0001+0.j    ]
 [-0.    -0.j      0.    +0.0001j -0.0002-0.0001j  0.0004-0.j     -0.0006+0.0004j  0.0005-0.001j   0.0001+0.0014j -0.0009-0.0013j  0.0014+0.0006j -0.0013+0.0002j  0.0007-0.0006j -0.0002+0.0006j -0.    -0.0003j  0.0001+0.0001j -0.0001-0.j      0.    +0.j    ]]
Sum of c^2 0.9927039945948724
Thu Apr 17 13:28:41 PDT 2025
