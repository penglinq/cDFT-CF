Currently Loaded Modulefiles:
 1) gmp/6.2.1-gcc-13.2.0-lcnhyse <aL>             
 2) mpfr/4.2.0-gcc-13.2.0-yy2fkq5 <aL>            
 3) mpc/1.3.1-gcc-13.2.0-5kgoftq <aL>             
 4) zlib-ng/2.1.3-gcc-13.2.0-jetnfwa <aL>         
 5) zstd/1.5.5-gcc-13.2.0-t2lua3l <aL>            
 6) gcc/13.2.0-gcc-13.2.0-w55nxkl                 
 7) cmake/3.20.2-gcc-13.2.0-rp74vpv               
 8) libfabric/1.18.1-gcc-13.2.0-bijxar4 <aL>      
 9) numactl/2.0.14-gcc-13.2.0-etkf74e <aL>        
10) openssh/8.7p1-gcc-13.2.0-g55xmkx <aL>         
11) slurm/22.05.6-gcc-13.2.0-tchsn6y <aL>         
12) openmpi/4.1.5-gcc-13.2.0-24q3ap2              
13) libpciaccess/0.17-gcc-13.2.0-r2cijnn <aL>     
14) libiconv/1.17-gcc-13.2.0-ntov4te <aL>         
15) xz/5.4.1-gcc-13.2.0-4xkm5xo <aL>              
16) libxml2/2.10.3-gcc-13.2.0-fr6jcjz <aL>        
17) ncurses/6.4-gcc-13.2.0-4o2yj6n <aL>           
18) hwloc/2.9.1-gcc-13.2.0-gzvfolk <aL>           
19) intel-tbb/2021.9.0-gcc-13.2.0-6nwk3ml <aL>    
20) intel-oneapi-mkl/2023.2.0-gcc-13.2.0-ohvyk7g  

Key:
<module-tag>  <aL>=auto-loaded  
/central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF
Thu Apr 17 13:26:13 PDT 2025
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
hpc-24-16.cm.cluster
--------------------------------------------------------------------------
WARNING: There was an error initializing an OpenFabrics device.

  Local host:   hpc-24-16
  Local device: mlx5_0
--------------------------------------------------------------------------
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:26:18 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                   #INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
       else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[CONFIG] conf_file None
[INPUT] num. atoms = 7
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
PySCF version 2.5.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6::
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


nuclear repulsion = 1868.38919656687
number of shells = 84
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6number of NR pGTOs = 449
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
ecp = {}
CPU time:         1.05
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
number of NR pGTOs = 449
number of NR cGTOs = 198
System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
N_elec (88, 83), N_ao 198
number of NR pGTOs = 449
number of NR cGTOs = 198
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

nuclear repulsion = 1868.38919656687
number of shells = 84
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.05
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.05
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
N_elec (88, 83), N_ao 198
CPU time:         1.05
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
N_elec (88, 83), N_ao 198
[CONFIG] conf_file None
[INPUT] verbose = 4
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] num. atoms = 7
N_elec (88, 83), N_ao 198
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

number of NR pGTOs = 449

number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.06
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
nuclear repulsion = 1868.38919656687
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
nuclear repulsion = 1868.38919656687
number of shells = 84
ecp = {}
CPU time:         1.04
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
number of NR pGTOs = 449
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
N_elec (88, 83), N_ao 198
ecp = {}
CPU time:         1.06
CPU time:         1.05
N_elec (88, 83), N_ao 198
N_elec (88, 83), N_ao 198
**** MO energy ****
MO #1   energy= -1986.50531770784  occ= 1
MO #2   energy= -1986.5052043097   occ= 1
MO #3   energy= -335.744462825175  occ= 1
MO #4   energy= -335.744004932689  occ= 1
MO #5   energy= -318.560728259261  occ= 1
MO #6   energy= -318.560470414136  occ= 1
MO #7   energy= -288.739745084877  occ= 1
MO #8   energy= -288.73937707129   occ= 1
MO #9   energy= -288.731613068552  occ= 1
MO #10  energy= -288.73148949399   occ= 1
MO #11  energy= -105.083399671176  occ= 1
MO #12  energy= -105.083378031639  occ= 1
MO #13  energy= -105.083263366792  occ= 1
MO #14  energy= -105.083241707041  occ= 1
MO #15  energy= -105.082365136564  occ= 1
MO #16  energy= -105.082361528631  occ= 1
MO #17  energy= -105.082233704022  occ= 1
MO #18  energy= -105.082230097262  occ= 1
MO #19  energy= -105.081571932462  occ= 1
MO #20  energy= -105.081551952953  occ= 1
MO #21  energy= -105.08144380838   occ= 1
MO #22  energy= -105.081423811704  occ= 1
MO #23  energy= -77.0768022438231  occ= 1
MO #24  energy= -76.9572832199474  occ= 1
MO #25  energy= -69.5782903555113  occ= 1
MO #26  energy= -69.5597176951703  occ= 1
MO #27  energy= -63.2150124770356  occ= 1
MO #28  energy= -63.2058389155977  occ= 1
MO #29  energy= -63.13066274715    occ= 1
MO #30  energy= -63.0453185058317  occ= 1
MO #31  energy= -50.7717559937406  occ= 1
MO #32  energy= -50.7677080140672  occ= 1
MO #33  energy= -50.7600333523277  occ= 1
MO #34  energy= -50.737595837852   occ= 1
MO #35  energy= -49.1961157720848  occ= 1
MO #36  energy= -49.1797068510928  occ= 1
MO #37  energy= -49.1678922081272  occ= 1
MO #38  energy= -49.0956585377706  occ= 1
MO #39  energy= -49.0501013531302  occ= 1
MO #40  energy= -48.9961227183825  occ= 1
MO #41  energy= -16.5561328943168  occ= 1
MO #42  energy= -16.241221774419   occ= 1
MO #43  energy= -13.4592913563961  occ= 1
MO #44  energy= -13.4141375824845  occ= 1
MO #45  energy= -12.0553913074884  occ= 1
MO #46  energy= -12.0154264603403  occ= 1
MO #47  energy= -11.8192229801372  occ= 1
MO #48  energy= -11.6604043322271  occ= 1
MO #49  energy= -10.4904599024773  occ= 1
MO #50  energy= -10.4904385095754  occ= 1
MO #51  energy= -10.4903111073487  occ= 1
MO #52  energy= -10.4902896937762  occ= 1
MO #53  energy= -10.4893936897921  occ= 1
MO #54  energy= -10.4893919863005  occ= 1
MO #55  energy= -10.4892498309289  occ= 1
MO #56  energy= -10.4892481293133  occ= 1
MO #57  energy= -10.4885842837024  occ= 1
MO #58  energy= -10.4885645743734  occ= 1
MO #59  energy= -10.4884445807431  occ= 1
MO #60  energy= -10.488424853756   occ= 1
MO #61  energy= -7.94760462499112  occ= 1
MO #62  energy= -7.94758319019131  occ= 1
MO #63  energy= -7.94750073842569  occ= 1
MO #64  energy= -7.9474792895621   occ= 1
MO #65  energy= -7.94655695992474  occ= 1
MO #66  energy= -7.94655525069197  occ= 1
MO #67  energy= -7.94642678546854  occ= 1
MO #68  energy= -7.94642507199814  occ= 1
MO #69  energy= -7.94575789251161  occ= 1
MO #70  energy= -7.94573814950412  occ= 1
MO #71  energy= -7.94561881673133  occ= 1
MO #72  energy= -7.94559905460556  occ= 1
MO #73  energy= -7.87973268327163  occ= 1
MO #74  energy= -7.87971116209801  occ= 1
MO #75  energy= -7.87947222123398  occ= 1
MO #76  energy= -7.87945066037704  occ= 1
MO #77  energy= -7.87881406642327  occ= 1
MO #78  energy= -7.87879214047586  occ= 1
MO #79  energy= -7.8787151417395   occ= 1
MO #80  energy= -7.87869318364815  occ= 1
MO #81  energy= -7.87866866597322  occ= 1
MO #82  energy= -7.87866626234087  occ= 1
MO #83  energy= -7.87840579302061  occ= 1
MO #84  energy= -7.87840326245417  occ= 1
MO #85  energy= -7.8778571168508   occ= 1
MO #86  energy= -7.87783728115136  occ= 1
MO #87  energy= -7.87774399225697  occ= 1
MO #88  energy= -7.8777387124085   occ= 1
MO #89  energy= -7.87768314424976  occ= 1
MO #90  energy= -7.87767814454506  occ= 1
MO #91  energy= -7.87759426375128  occ= 1
MO #92  energy= -7.87757443788397  occ= 1
MO #93  energy= -7.87691551253578  occ= 1
MO #94  energy= -7.87690381034569  occ= 1
MO #95  energy= -7.87689515270053  occ= 1
MO #96  energy= -7.87688345630414  occ= 1
MO #97  energy= -7.14125110388464  occ= 1
MO #98  energy= -7.14011206159926  occ= 1
MO #99  energy= -7.11088285235625  occ= 1
MO #100 energy= -7.04919969324553  occ= 1
MO #101 energy= -6.81800568891447  occ= 1
MO #102 energy= -6.77089826111738  occ= 1
MO #103 energy= -6.6104950902825   occ= 1
MO #104 energy= -6.39850472821599  occ= 1
MO #105 energy= -6.33426966231792  occ= 1
MO #106 energy= -6.23759491332842  occ= 1
MO #107 energy= -2.38436544973215  occ= 1
MO #108 energy= -2.26771232487121  occ= 1
MO #109 energy= -1.41546371124975  occ= 1
MO #110 energy= -1.41181188798873  occ= 1
MO #111 energy= -1.22106209046488  occ= 1
MO #112 energy= -1.21523265141829  occ= 1
MO #113 energy= -1.17900556324869  occ= 1
MO #114 energy= -1.13418543243145  occ= 1
MO #115 energy= -0.953121992899745 occ= 1
MO #116 energy= -0.952553517637298 occ= 1
MO #117 energy= -0.94479367799373  occ= 1
MO #118 energy= -0.943878103263135 occ= 1
MO #119 energy= -0.94361651721218  occ= 1
MO #120 energy= -0.942716709738754 occ= 1
MO #121 energy= -0.941909318392411 occ= 1
MO #122 energy= -0.941607373035495 occ= 1
MO #123 energy= -0.937446437912946 occ= 1
MO #124 energy= -0.936858161002581 occ= 1
MO #125 energy= -0.936078269943992 occ= 1
MO #126 energy= -0.933199641957313 occ= 1
MO #127 energy= -0.859037904976684 occ= 1
MO #128 energy= -0.854531362969557 occ= 1
MO #129 energy= -0.837714843720515 occ= 1
MO #130 energy= -0.815582232231545 occ= 1
MO #131 energy= -0.781001029061688 occ= 1
MO #132 energy= -0.777678196671117 occ= 1
MO #133 energy= -0.728029100518544 occ= 1
MO #134 energy= -0.631658037128961 occ= 1
MO #135 energy= -0.617561021252232 occ= 1
MO #136 energy= -0.406350203357959 occ= 1
MO #137 energy= -0.405113837938507 occ= 1
MO #138 energy= -0.382739821821722 occ= 1
MO #139 energy= -0.381922054232234 occ= 1
MO #140 energy= -0.380746941285361 occ= 1
MO #141 energy= -0.380250426007659 occ= 1
MO #142 energy= -0.372268573691411 occ= 1
MO #143 energy= -0.371882393269241 occ= 1
MO #144 energy= -0.371213624668215 occ= 1
MO #145 energy= -0.371133526260765 occ= 1
MO #146 energy= -0.370528912869804 occ= 1
MO #147 energy= -0.370411328582162 occ= 1
MO #148 energy= -0.368649093595186 occ= 1
MO #149 energy= -0.368467616161055 occ= 1
MO #150 energy= -0.368358519560609 occ= 1
MO #151 energy= -0.368086395583105 occ= 1
MO #152 energy= -0.367708357489702 occ= 1
MO #153 energy= -0.366336024598599 occ= 1
MO #154 energy= -0.343166710709586 occ= 1
MO #155 energy= -0.342280794650607 occ= 1
MO #156 energy= -0.341341852878504 occ= 1
MO #157 energy= -0.340898354309308 occ= 1
MO #158 energy= -0.340583750309371 occ= 1
MO #159 energy= -0.340303806927934 occ= 1
MO #160 energy= -0.338208574871598 occ= 1
MO #161 energy= -0.338091952900745 occ= 1
MO #162 energy= -0.335393037718144 occ= 1
MO #163 energy= -0.334864611570309 occ= 1
MO #164 energy= -0.334596589820126 occ= 1
MO #165 energy= -0.333918401812479 occ= 1
MO #166 energy= -0.327141360157402 occ= 1
MO #167 energy= -0.326904319308736 occ= 1
MO #168 energy= -0.32449687178005  occ= 1
MO #169 energy= -0.324132980174907 occ= 1
MO #170 energy= -0.323838007747584 occ= 1
MO #171 energy= -0.323627051935857 occ= 1
MO #172 energy= 0.122828509684916  occ= 0
MO #173 energy= 0.12291082337871   occ= 0
MO #174 energy= 0.123032207018609  occ= 0
MO #175 energy= 0.123057678561431  occ= 0
MO #176 energy= 0.123146266601502  occ= 0
MO #177 energy= 0.123226066368191  occ= 0
MO #178 energy= 0.129556749284085  occ= 0
MO #179 energy= 0.129561652519908  occ= 0
MO #180 energy= 0.129753560582258  occ= 0
MO #181 energy= 0.129759042872476  occ= 0
MO #182 energy= 0.129973815076393  occ= 0
MO #183 energy= 0.129977569240811  occ= 0
MO #184 energy= 0.133444671166164  occ= 0
MO #185 energy= 0.133549959032476  occ= 0
MO #186 energy= 0.153421906055289  occ= 0
MO #187 energy= 0.153824095418233  occ= 0
MO #188 energy= 0.153895618369371  occ= 0
MO #189 energy= 0.154230997184818  occ= 0
MO #190 energy= 0.204658227321707  occ= 0
MO #191 energy= 0.207792180332021  occ= 0
MO #192 energy= 0.215813607180204  occ= 0
MO #193 energy= 0.224787861208267  occ= 0
MO #194 energy= 0.230452295844761  occ= 0
MO #195 energy= 0.238119789814722  occ= 0
MO #196 energy= 0.292417923970193  occ= 0
MO #197 energy= 0.296860638316152  occ= 0
MO #198 energy= 0.297112151314283  occ= 0
MO #199 energy= 0.2982744039332    occ= 0
MO #200 energy= 0.298510780527408  occ= 0
MO #201 energy= 0.298710342700632  occ= 0
MO #202 energy= 0.298881404286258  occ= 0
MO #203 energy= 0.301477732546136  occ= 0
MO #204 energy= 0.310260498977512  occ= 0
MO #205 energy= 0.312297082748785  occ= 0
MO #206 energy= 0.320267241290305  occ= 0
MO #207 energy= 0.323042076186406  occ= 0
MO #208 energy= 0.337070965501619  occ= 0
MO #209 energy= 0.337393207382808  occ= 0
MO #210 energy= 0.338407986172637  occ= 0
MO #211 energy= 0.339502005524163  occ= 0
MO #212 energy= 0.340494990932422  occ= 0
MO #213 energy= 0.341654158713465  occ= 0
MO #214 energy= 0.343368551845236  occ= 0
MO #215 energy= 0.344235978697562  occ= 0
MO #216 energy= 0.34862311365291   occ= 0
MO #217 energy= 0.351282477293033  occ= 0
MO #218 energy= 0.404174811385625  occ= 0
MO #219 energy= 0.411472357704592  occ= 0
MO #220 energy= 0.436423730519522  occ= 0
MO #221 energy= 0.442718674984202  occ= 0
MO #222 energy= 0.467225625060475  occ= 0
MO #223 energy= 0.473330009941976  occ= 0
MO #224 energy= 0.485351291188436  occ= 0
MO #225 energy= 0.493781940693205  occ= 0
MO #226 energy= 0.497400300610811  occ= 0
MO #227 energy= 0.49959842696499   occ= 0
MO #228 energy= 0.515292725241709  occ= 0
MO #229 energy= 0.52187157927503   occ= 0
MO #230 energy= 0.543355133760529  occ= 0
MO #231 energy= 0.547153469185515  occ= 0
MO #232 energy= 0.588084201440475  occ= 0
MO #233 energy= 0.606410847628661  occ= 0
MO #234 energy= 0.607351476760512  occ= 0
MO #235 energy= 0.608131689446732  occ= 0
MO #236 energy= 0.612249043311136  occ= 0
MO #237 energy= 0.618703521956152  occ= 0
MO #238 energy= 0.626651150525454  occ= 0
MO #239 energy= 0.629209248782262  occ= 0
MO #240 energy= 0.631157389116725  occ= 0
MO #241 energy= 0.635835525889302  occ= 0
MO #242 energy= 0.661133709562218  occ= 0
MO #243 energy= 0.674883870573909  occ= 0
MO #244 energy= 0.68641255365857   occ= 0
MO #245 energy= 0.742907878099456  occ= 0
MO #246 energy= 0.745225992445712  occ= 0
MO #247 energy= 0.748489820228239  occ= 0
MO #248 energy= 0.74990281185304   occ= 0
MO #249 energy= 0.770581340883261  occ= 0
MO #250 energy= 0.771057067944399  occ= 0
MO #251 energy= 0.773164568986851  occ= 0
MO #252 energy= 0.77574701569245   occ= 0
MO #253 energy= 0.777198415236036  occ= 0
MO #254 energy= 0.777301462426565  occ= 0
MO #255 energy= 0.777649468870127  occ= 0
MO #256 energy= 0.777696620081852  occ= 0
MO #257 energy= 0.780523182848617  occ= 0
MO #258 energy= 0.780587351378636  occ= 0
MO #259 energy= 0.783418155624854  occ= 0
MO #260 energy= 0.795276385182842  occ= 0
MO #261 energy= 0.801273792223572  occ= 0
MO #262 energy= 0.801647590625832  occ= 0
MO #263 energy= 0.802999202583547  occ= 0
MO #264 energy= 0.804813917613081  occ= 0
MO #265 energy= 0.805265891381667  occ= 0
MO #266 energy= 0.805720048293144  occ= 0
MO #267 energy= 0.806420966664581  occ= 0
MO #268 energy= 0.812092340123734  occ= 0
MO #269 energy= 0.867205649719008  occ= 0
MO #270 energy= 0.867297236343106  occ= 0
MO #271 energy= 0.869940953386161  occ= 0
MO #272 energy= 0.870095964483952  occ= 0
MO #273 energy= 0.870375804296069  occ= 0
MO #274 energy= 0.870463109866296  occ= 0
MO #275 energy= 0.933116792014848  occ= 0
MO #276 energy= 0.93369435365981   occ= 0
MO #277 energy= 0.934101995761491  occ= 0
MO #278 energy= 0.934340223674687  occ= 0
MO #279 energy= 0.937499799709293  occ= 0
MO #280 energy= 0.938178057927377  occ= 0
MO #281 energy= 1.01765840048085   occ= 0
MO #282 energy= 1.01871244571319   occ= 0
MO #283 energy= 1.0206080150961    occ= 0
MO #284 energy= 1.02138469896709   occ= 0
MO #285 energy= 1.02396727886603   occ= 0
MO #286 energy= 1.02506019890378   occ= 0
MO #287 energy= 1.02956904772435   occ= 0
MO #288 energy= 1.04062208870597   occ= 0
MO #289 energy= 1.04321113071692   occ= 0
MO #290 energy= 1.04466178854467   occ= 0
MO #291 energy= 1.09199223145288   occ= 0
MO #292 energy= 1.09204127011298   occ= 0
MO #293 energy= 1.09432725561029   occ= 0
MO #294 energy= 1.09447234493175   occ= 0
MO #295 energy= 1.09471869421084   occ= 0
MO #296 energy= 1.09517556192986   occ= 0
MO #297 energy= 1.10812882846767   occ= 0
MO #298 energy= 1.11236067458954   occ= 0
MO #299 energy= 1.12192372949817   occ= 0
MO #300 energy= 1.12478545534993   occ= 0
MO #301 energy= 1.32560683231098   occ= 0
MO #302 energy= 1.33043790044457   occ= 0
MO #303 energy= 1.37038449459471   occ= 0
MO #304 energy= 1.38316402050644   occ= 0
MO #305 energy= 1.52871902858261   occ= 0
MO #306 energy= 1.53672758466355   occ= 0
MO #307 energy= 1.55434355288725   occ= 0
MO #308 energy= 1.58937833789953   occ= 0
MO #309 energy= 1.59918617610013   occ= 0
MO #310 energy= 1.60377810682713   occ= 0
MO #311 energy= 1.60582072939958   occ= 0
MO #312 energy= 1.61180623888174   occ= 0
MO #313 energy= 1.62141134704412   occ= 0
MO #314 energy= 1.62335559216713   occ= 0
MO #315 energy= 1.6407087496658    occ= 0
MO #316 energy= 1.6831645652829    occ= 0
MO #317 energy= 1.70785864526257   occ= 0
MO #318 energy= 1.71057218653246   occ= 0
MO #319 energy= 1.855205950443     occ= 0
MO #320 energy= 1.86298551270742   occ= 0
MO #321 energy= 1.88045358415095   occ= 0
MO #322 energy= 1.91853807292308   occ= 0
MO #323 energy= 1.92583621269482   occ= 0
MO #324 energy= 1.93106783666812   occ= 0
MO #325 energy= 2.64965545992832   occ= 0
MO #326 energy= 2.66073648549564   occ= 0
MO #327 energy= 2.68019600243917   occ= 0
MO #328 energy= 2.70796535499398   occ= 0
MO #329 energy= 2.74198847730197   occ= 0
MO #330 energy= 2.76524667074664   occ= 0
MO #331 energy= 2.83263595627073   occ= 0
MO #332 energy= 2.85069955764144   occ= 0
MO #333 energy= 2.89809680670921   occ= 0
MO #334 energy= 2.91443712777765   occ= 0
MO #335 energy= 4.40983253110226   occ= 0
MO #336 energy= 4.46556543563163   occ= 0
MO #337 energy= 5.73106246271777   occ= 0
MO #338 energy= 5.74301368573515   occ= 0
MO #339 energy= 6.24317186472327   occ= 0
MO #340 energy= 6.25321282812314   occ= 0
MO #341 energy= 6.28282695533726   occ= 0
MO #342 energy= 6.34080726787003   occ= 0
MO #343 energy= 11.4065437123089   occ= 0
MO #344 energy= 11.4213697917088   occ= 0
MO #345 energy= 11.4466113499235   occ= 0
MO #346 energy= 11.4849033688559   occ= 0
MO #347 energy= 11.7329984837396   occ= 0
MO #348 energy= 11.7610243546776   occ= 0
MO #349 energy= 11.782537757334    occ= 0
MO #350 energy= 11.8044489763753   occ= 0
MO #351 energy= 11.8673450504989   occ= 0
MO #352 energy= 11.919766545277    occ= 0
MO #353 energy= 16.7876118840329   occ= 0
MO #354 energy= 16.8805919016478   occ= 0
MO #355 energy= 27.9148538540431   occ= 0
MO #356 energy= 27.9373118815024   occ= 0
MO #357 energy= 31.0817190412742   occ= 0
MO #358 energy= 31.1142228633369   occ= 0
MO #359 energy= 31.1330016539533   occ= 0
MO #360 energy= 31.2151165989225   occ= 0
MO #361 energy= 60.4328445353795   occ= 0
MO #362 energy= 60.4400103194127   occ= 0
MO #363 energy= 60.4659822046355   occ= 0
MO #364 energy= 60.4957428800662   occ= 0
MO #365 energy= 62.6199607636569   occ= 0
MO #366 energy= 62.6380762028373   occ= 0
MO #367 energy= 62.6559194791149   occ= 0
MO #368 energy= 62.6700549183283   occ= 0
MO #369 energy= 62.7018618699155   occ= 0
MO #370 energy= 62.7484364048064   occ= 0
MO #371 energy= 71.974114199341    occ= 0
MO #372 energy= 72.0425006186315   occ= 0
MO #373 energy= 150.734069129082   occ= 0
MO #374 energy= 150.743397760177   occ= 0
MO #375 energy= 165.183480420813   occ= 0
MO #376 energy= 165.201723217301   occ= 0
MO #377 energy= 165.211109327449   occ= 0
MO #378 energy= 165.245582515309   occ= 0
MO #379 energy= 294.470779404963   occ= 0
MO #380 energy= 294.491173384329   occ= 0
MO #381 energy= 690.538353083014   occ= 0
MO #382 energy= 690.539827936619   occ= 0
MO #383 energy= 798.98637493244    occ= 0
MO #384 energy= 798.988883673717   occ= 0
MO #385 energy= 798.996448956354   occ= 0
MO #386 energy= 799.001056827416   occ= 0
MO #387 energy= 1008.64575958312   occ= 0
MO #388 energy= 1008.64977928263   occ= 0
MO #389 energy= 2865.03476876281   occ= 0
MO #390 energy= 2865.03566037772   occ= 0
MO #391 energy= 6964.91701690689   occ= 0
MO #392 energy= 6964.91728144245   occ= 0
MO #393 energy= 14850.4541440237   occ= 0
MO #394 energy= 14850.4542363467   occ= 0
MO #395 energy= 35043.591433682    occ= 0
MO #396 energy= 35043.5914627632   occ= 0
 ** Mulliken pop alpha/beta on meta-lowdin orthogonal AOs **
 ** Mulliken pop       alpha | beta **
pop of  0 Dy 1s        0.99999 | 0.99999   
pop of  0 Dy 2s        1.00000 | 1.00000   
pop of  0 Dy 3s        1.00000 | 1.00000   
pop of  0 Dy 4s        0.99999 | 0.99999   
pop of  0 Dy 5s        0.99812 | 0.99826   
pop of  0 Dy 6s        0.19748 | 0.19694   
pop of  0 Dy 7s        0.00666 | 0.00651   
pop of  0 Dy 8s        0.00038 | 0.00036   
pop of  0 Dy 9s        0.00024 | 0.00024   
pop of  0 Dy 10s        0.00018 | 0.00017   
pop of  0 Dy 11s        0.00000 | 0.00000   
pop of  0 Dy 12s        0.00001 | 0.00001   
pop of  0 Dy 13s        0.00001 | 0.00001   
pop of  0 Dy 14s        0.00000 | 0.00000   
pop of  0 Dy 15s        0.00000 | 0.00000   
pop of  0 Dy 16s        0.00000 | 0.00000   
pop of  0 Dy 17s        0.00000 | 0.00000   
pop of  0 Dy 18s        0.00000 | 0.00000   
pop of  0 Dy 2px       0.99897 | 0.99897   
pop of  0 Dy 2py       0.99897 | 0.99897   
pop of  0 Dy 2pz       0.99897 | 0.99897   
pop of  0 Dy 3px       0.99875 | 0.99875   
pop of  0 Dy 3py       0.99875 | 0.99875   
pop of  0 Dy 3pz       0.99875 | 0.99875   
pop of  0 Dy 4px       0.99838 | 0.99838   
pop of  0 Dy 4py       0.99838 | 0.99838   
pop of  0 Dy 4pz       0.99838 | 0.99838   
pop of  0 Dy 5px       0.99568 | 0.99585   
pop of  0 Dy 5py       0.99534 | 0.99554   
pop of  0 Dy 5pz       0.99588 | 0.99605   
pop of  0 Dy 6px       0.00670 | 0.00653   
pop of  0 Dy 6py       0.00710 | 0.00690   
pop of  0 Dy 6pz       0.00646 | 0.00630   
pop of  0 Dy 7px       0.00317 | 0.00310   
pop of  0 Dy 7py       0.00335 | 0.00326   
pop of  0 Dy 7pz       0.00306 | 0.00298   
pop of  0 Dy 8px       0.00156 | 0.00155   
pop of  0 Dy 8py       0.00160 | 0.00159   
pop of  0 Dy 8pz       0.00154 | 0.00153   
pop of  0 Dy 9px       0.00069 | 0.00069   
pop of  0 Dy 9py       0.00070 | 0.00069   
pop of  0 Dy 9pz       0.00069 | 0.00068   
pop of  0 Dy 10px       0.00071 | 0.00071   
pop of  0 Dy 10py       0.00070 | 0.00070   
pop of  0 Dy 10pz       0.00071 | 0.00071   
pop of  0 Dy 11px       0.00068 | 0.00068   
pop of  0 Dy 11py       0.00067 | 0.00067   
pop of  0 Dy 11pz       0.00068 | 0.00068   
pop of  0 Dy 12px       0.00059 | 0.00059   
pop of  0 Dy 12py       0.00059 | 0.00059   
pop of  0 Dy 12pz       0.00059 | 0.00059   
pop of  0 Dy 13px       0.00107 | 0.00107   
pop of  0 Dy 13py       0.00107 | 0.00107   
pop of  0 Dy 13pz       0.00107 | 0.00107   
pop of  0 Dy 3dxy      0.99991 | 0.99991   
pop of  0 Dy 3dyz      0.99991 | 0.99991   
pop of  0 Dy 3dz^2     0.99991 | 0.99991   
pop of  0 Dy 3dxz      0.99991 | 0.99991   
pop of  0 Dy 3dx2-y2    0.99991 | 0.99991   
pop of  0 Dy 4dxy      0.99972 | 0.99972   
pop of  0 Dy 4dyz      0.99973 | 0.99973   
pop of  0 Dy 4dz^2     0.99974 | 0.99974   
pop of  0 Dy 4dxz      0.99974 | 0.99974   
pop of  0 Dy 4dx2-y2    0.99972 | 0.99972   
pop of  0 Dy 5dxy      0.01430 | 0.01409   
pop of  0 Dy 5dyz      0.01401 | 0.01386   
pop of  0 Dy 5dz^2     0.03392 | 0.03346   
pop of  0 Dy 5dxz      0.01375 | 0.01362   
pop of  0 Dy 5dx2-y2    0.03502 | 0.03441   
pop of  0 Dy 6dxy      0.00165 | 0.00166   
pop of  0 Dy 6dyz      0.00162 | 0.00164   
pop of  0 Dy 6dz^2     0.00044 | 0.00043   
pop of  0 Dy 6dxz      0.00163 | 0.00164   
pop of  0 Dy 6dx2-y2    0.00048 | 0.00046   
pop of  0 Dy 7dxy      0.00014 | 0.00014   
pop of  0 Dy 7dyz      0.00014 | 0.00014   
pop of  0 Dy 7dz^2     0.00243 | 0.00242   
pop of  0 Dy 7dxz      0.00014 | 0.00014   
pop of  0 Dy 7dx2-y2    0.00250 | 0.00248   
pop of  0 Dy 8dxy      0.00004 | 0.00004   
pop of  0 Dy 8dyz      0.00004 | 0.00004   
pop of  0 Dy 8dz^2     0.00095 | 0.00095   
pop of  0 Dy 8dxz      0.00004 | 0.00004   
pop of  0 Dy 8dx2-y2    0.00097 | 0.00097   
pop of  0 Dy 9dxy      0.00009 | 0.00009   
pop of  0 Dy 9dyz      0.00009 | 0.00009   
pop of  0 Dy 9dz^2     0.00017 | 0.00018   
pop of  0 Dy 9dxz      0.00009 | 0.00009   
pop of  0 Dy 9dx2-y2    0.00017 | 0.00017   
pop of  0 Dy 10dxy      0.00015 | 0.00014   
pop of  0 Dy 10dyz      0.00014 | 0.00014   
pop of  0 Dy 10dz^2     0.00014 | 0.00014   
pop of  0 Dy 10dxz      0.00014 | 0.00014   
pop of  0 Dy 10dx2-y2    0.00014 | 0.00014   
pop of  0 Dy 11dxy      0.00018 | 0.00018   
pop of  0 Dy 11dyz      0.00017 | 0.00017   
pop of  0 Dy 11dz^2     0.00002 | 0.00002   
pop of  0 Dy 11dxz      0.00017 | 0.00017   
pop of  0 Dy 11dx2-y2    0.00002 | 0.00002   
pop of  0 Dy 4f-3      0.58036 | 0.47995   
pop of  0 Dy 4f-2      0.66436 | 0.59310   
pop of  0 Dy 4f-1      0.68708 | 0.65711   
pop of  0 Dy 4f+0      0.68624 | 0.62549   
pop of  0 Dy 4f+1      0.72405 | 0.69232   
pop of  0 Dy 4f+2      0.73839 | 0.69784   
pop of  0 Dy 4f+3      0.62499 | 0.54540   
pop of  0 Dy 5f-3      0.00162 | 0.00150   
pop of  0 Dy 5f-2      0.00082 | 0.00070   
pop of  0 Dy 5f-1      0.00125 | 0.00115   
pop of  0 Dy 5f+0      0.00159 | 0.00150   
pop of  0 Dy 5f+1      0.00111 | 0.00102   
pop of  0 Dy 5f+2      0.00097 | 0.00087   
pop of  0 Dy 5f+3      0.00159 | 0.00146   
pop of  0 Dy 6f-3      0.00200 | 0.00199   
pop of  0 Dy 6f-2      0.00013 | 0.00011   
pop of  0 Dy 6f-1      0.00178 | 0.00176   
pop of  0 Dy 6f+0      0.00217 | 0.00216   
pop of  0 Dy 6f+1      0.00174 | 0.00172   
pop of  0 Dy 6f+2      0.00150 | 0.00148   
pop of  0 Dy 6f+3      0.00198 | 0.00197   
pop of  1 Cl 1s        1.00000 | 1.00000   
pop of  1 Cl 2s        1.00000 | 1.00000   
pop of  1 Cl 3s        0.98077 | 0.98079   
pop of  1 Cl 4s        0.00145 | 0.00143   
pop of  1 Cl 2px       1.00000 | 1.00000   
pop of  1 Cl 2py       1.00000 | 1.00000   
pop of  1 Cl 2pz       1.00000 | 1.00000   
pop of  1 Cl 3px       0.96650 | 0.96679   
pop of  1 Cl 3py       0.99243 | 0.99244   
pop of  1 Cl 3pz       0.99272 | 0.99275   
pop of  1 Cl 4px       0.00190 | 0.00188   
pop of  1 Cl 4py       0.00170 | 0.00169   
pop of  1 Cl 4pz       0.00168 | 0.00167   
pop of  2 Cl 1s        1.00000 | 1.00000   
pop of  2 Cl 2s        1.00000 | 1.00000   
pop of  2 Cl 3s        0.98077 | 0.98079   
pop of  2 Cl 4s        0.00145 | 0.00143   
pop of  2 Cl 2px       1.00000 | 1.00000   
pop of  2 Cl 2py       1.00000 | 1.00000   
pop of  2 Cl 2pz       1.00000 | 1.00000   
pop of  2 Cl 3px       0.96650 | 0.96679   
pop of  2 Cl 3py       0.99243 | 0.99244   
pop of  2 Cl 3pz       0.99272 | 0.99275   
pop of  2 Cl 4px       0.00190 | 0.00188   
pop of  2 Cl 4py       0.00170 | 0.00169   
pop of  2 Cl 4pz       0.00168 | 0.00167   
pop of  3 Cl 1s        1.00000 | 1.00000   
pop of  3 Cl 2s        1.00000 | 1.00000   
pop of  3 Cl 3s        0.98076 | 0.98077   
pop of  3 Cl 4s        0.00148 | 0.00146   
pop of  3 Cl 2px       1.00000 | 1.00000   
pop of  3 Cl 2py       1.00000 | 1.00000   
pop of  3 Cl 2pz       1.00000 | 1.00000   
pop of  3 Cl 3px       0.99250 | 0.99253   
pop of  3 Cl 3py       0.96600 | 0.96628   
pop of  3 Cl 3pz       0.99263 | 0.99265   
pop of  3 Cl 4px       0.00167 | 0.00167   
pop of  3 Cl 4py       0.00191 | 0.00188   
pop of  3 Cl 4pz       0.00166 | 0.00166   
pop of  4 Cl 1s        1.00000 | 1.00000   
pop of  4 Cl 2s        1.00000 | 1.00000   
pop of  4 Cl 3s        0.98076 | 0.98077   
pop of  4 Cl 4s        0.00148 | 0.00146   
pop of  4 Cl 2px       1.00000 | 1.00000   
pop of  4 Cl 2py       1.00000 | 1.00000   
pop of  4 Cl 2pz       1.00000 | 1.00000   
pop of  4 Cl 3px       0.99250 | 0.99253   
pop of  4 Cl 3py       0.96600 | 0.96629   
pop of  4 Cl 3pz       0.99264 | 0.99265   
pop of  4 Cl 4px       0.00167 | 0.00167   
pop of  4 Cl 4py       0.00191 | 0.00188   
pop of  4 Cl 4pz       0.00166 | 0.00166   
pop of  5 Cl 1s        1.00000 | 1.00000   
pop of  5 Cl 2s        1.00000 | 1.00000   
pop of  5 Cl 3s        0.98077 | 0.98078   
pop of  5 Cl 4s        0.00143 | 0.00141   
pop of  5 Cl 2px       1.00000 | 1.00000   
pop of  5 Cl 2py       1.00000 | 1.00000   
pop of  5 Cl 2pz       1.00000 | 1.00000   
pop of  5 Cl 3px       0.99265 | 0.99268   
pop of  5 Cl 3py       0.99251 | 0.99255   
pop of  5 Cl 3pz       0.96658 | 0.96684   
pop of  5 Cl 4px       0.00169 | 0.00169   
pop of  5 Cl 4py       0.00171 | 0.00170   
pop of  5 Cl 4pz       0.00189 | 0.00187   
pop of  6 Cl 1s        1.00000 | 1.00000   
pop of  6 Cl 2s        1.00000 | 1.00000   
pop of  6 Cl 3s        0.98077 | 0.98078   
pop of  6 Cl 4s        0.00143 | 0.00141   
pop of  6 Cl 2px       1.00000 | 1.00000   
pop of  6 Cl 2py       1.00000 | 1.00000   
pop of  6 Cl 2pz       1.00000 | 1.00000   
pop of  6 Cl 3px       0.99265 | 0.99268   
pop of  6 Cl 3py       0.99251 | 0.99255   
pop of  6 Cl 3pz       0.96658 | 0.96684   
pop of  6 Cl 4px       0.00169 | 0.00169   
pop of  6 Cl 4py       0.00171 | 0.00170   
pop of  6 Cl 4pz       0.00189 | 0.00187   
In total            85.70794 | 85.29206  
 ** Mulliken atomic charges   ( Nelec_alpha | Nelec_beta ) **
charge of  0Dy =      2.26959  (    32.07401     31.65641 )
charge of  1Cl =     -0.87858  (     8.93914      8.93944 )
charge of  2Cl =     -0.87858  (     8.93914      8.93944 )
charge of  3Cl =     -0.87748  (     8.93860      8.93888 )
charge of  4Cl =     -0.87749  (     8.93861      8.93888 )
charge of  5Cl =     -0.87874  (     8.93923      8.93951 )
charge of  6Cl =     -0.87872  (     8.93922      8.93950 )
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.21
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.22
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:20 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.23
N_elec (88, 83), N_ao 198
(3, 198, 198) 198
S vector [ 1.2718-0.j -2.0046+0.j  0.2079+0.j]
(3, 198, 198) 198
L vector [ 2.7048+0.j -4.3192+0.j  0.4335+0.j]
(3, 198, 198) 198
J vector [ 3.9766-0.j -6.3239+0.j  0.6415+0.j]
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:21 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.24
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:21 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************

basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.24
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_72/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:21 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.24
N_elec (88, 83), N_ao 198

System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:21 2025
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-24-16.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:26:21 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.24
N_elec (88, 83), N_ao 198
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         1.23
N_elec (88, 83), N_ao 198
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

ao_index [ 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317]
ao_labels ['0 Dy 4f-3  ' '0 Dy 4f-2  ' '0 Dy 4f-1  ' '0 Dy 4f+0  ' '0 Dy 4f+1  ' '0 Dy 4f+2  ' '0 Dy 4f+3  ' '0 Dy 5f-3  ' '0 Dy 5f-2  ' '0 Dy 5f-1  ' '0 Dy 5f+0  ' '0 Dy 5f+1  ' '0 Dy 5f+2  ' '0 Dy 5f+3  ' '0 Dy 6f-3  ' '0 Dy 6f-2  ' '0 Dy 6f-1  ' '0 Dy 6f+0  ' '0 Dy 6f+1  ' '0 Dy 6f+2  ' '0 Dy 6f+3  ']
  J     M     c^2  
rank = 0, idx_lst = [ 0 16]
rank = 10, idx_lst = [10 26]
rank = 12, idx_lst = [12 28]
rank = 6, idx_lst = [ 6 22]
rank = 14, idx_lst = [14]
rank = 8, idx_lst = [ 8 24]
rank = 4, idx_lst = [ 4 20]
rank = 2, idx_lst = [ 2 18]
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!
LO diff from identity 0.003969852403580924

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

WARN: LO is not orthonormal!



WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


rank = 3, idx_lst = [ 3 19]
rank = 9, idx_lst = [ 9 25]
rank = 15, idx_lst = [15]
rank = 7, idx_lst = [ 7 23]
rank = 1, idx_lst = [ 1 17]
rank = 13, idx_lst = [13]
rank = 11, idx_lst = [11 27]
rank = 5, idx_lst = [ 5 21]
[hpc-24-16.cm.cluster:2907490] 15 more processes have sent help message help-mpi-btl-openib.txt / error in device init
[hpc-24-16.cm.cluster:2907490] Set MCA parameter "orte_base_help_aggregate" to 0 to see all help / error messages
 7.5    7.5    7.5    0.00008    0.00001
 7.5    7.5    6.5    0.00013   -0.00024
 7.5    7.5    5.5   -0.00036   -0.00060
 7.5    7.5    4.5   -0.00137   -0.00001
 7.5    7.5    3.5   -0.00120    0.00190
 7.5    7.5    2.5    0.00136    0.00280
 7.5    7.5    1.5    0.00370    0.00040
 7.5    7.5    0.5    0.00242   -0.00305
 7.5    7.5   -0.5   -0.00118   -0.00336
 7.5    7.5   -1.5   -0.00278   -0.00064
 7.5    7.5   -2.5   -0.00141    0.00141
 7.5    7.5   -3.5    0.00027    0.00116
 7.5    7.5   -4.5    0.00058    0.00019
 7.5    7.5   -5.5    0.00019   -0.00017
 7.5    7.5   -6.5   -0.00002   -0.00008
 7.5    7.5   -7.5   -0.00002   -0.00000
 7.5    6.5    6.5    0.00105    0.00001
 7.5    6.5    5.5    0.00134   -0.00227
 7.5    6.5    4.5   -0.00247   -0.00459
 7.5    6.5    3.5   -0.00848   -0.00051
 7.5    6.5    2.5   -0.00681    0.00960
 7.5    6.5    1.5    0.00539    0.01301
 7.5    6.5    0.5    0.01449    0.00249
 7.5    6.5   -0.5    0.00901   -0.00999
 7.5    6.5   -1.5   -0.00293   -0.01038
 7.5    6.5   -2.5   -0.00722   -0.00211
 7.5    6.5   -3.5   -0.00336    0.00302
 7.5    6.5   -4.5    0.00043    0.00226
 7.5    6.5   -5.5    0.00090    0.00032
 7.5    6.5   -6.5    0.00022   -0.00020
 7.5    6.5   -7.5   -0.00002   -0.00006
 7.5    5.5    5.5    0.00672    0.00004
 7.5    5.5    4.5    0.00690   -0.01132
 7.5    5.5    3.5   -0.00977   -0.01922
 7.5    5.5    2.5   -0.02972   -0.00264
 7.5    5.5    1.5   -0.02161    0.02842
 7.5    5.5    0.5    0.01306    0.03494
 7.5    5.5   -0.5    0.03342    0.00696
 7.5    5.5   -1.5    0.01899   -0.01969
 7.5    5.5   -2.5   -0.00462   -0.01852
 7.5    5.5   -3.5   -0.01092   -0.00350
 7.5    5.5   -4.5   -0.00439    0.00382
 7.5    5.5   -5.5    0.00045    0.00237
 7.5    5.5   -6.5    0.00073    0.00023
 7.5    5.5   -7.5    0.00011   -0.00012
 7.5    4.5    4.5    0.02615    0.00007
 7.5    4.5    3.5    0.02241   -0.03613
 7.5    4.5    2.5   -0.02593   -0.05277
 7.5    4.5    1.5   -0.06995   -0.00739
 7.5    4.5    0.5   -0.04554    0.05767
 7.5    4.5   -0.5    0.02239    0.06343
 7.5    4.5   -1.5    0.05258    0.01190
 7.5    4.5   -2.5    0.02651   -0.02670
 7.5    4.5   -3.5   -0.00526   -0.02199
 7.5    4.5   -4.5   -0.01092   -0.00350
 7.5    4.5   -5.5   -0.00352    0.00318
 7.5    4.5   -6.5    0.00036    0.00146
 7.5    4.5   -7.5    0.00031    0.00006
 7.5    3.5    3.5    0.06913    0.00007
 7.5    3.5    2.5    0.05075   -0.08098
 7.5    3.5    1.5   -0.04962   -0.10297
 7.5    3.5    0.5   -0.11861   -0.01361
 7.5    3.5   -0.5   -0.06851    0.08517
 7.5    3.5   -1.5    0.02852    0.08284
 7.5    3.5   -2.5    0.05956    0.01381
 7.5    3.5   -3.5    0.02589   -0.02607
 7.5    3.5   -4.5   -0.00451   -0.01808
 7.5    3.5   -5.5   -0.00740   -0.00215
 7.5    3.5   -6.5   -0.00171    0.00174
 7.5    3.5   -7.5    0.00019    0.00047
 7.5    2.5    2.5    0.13211    0.00006
 7.5    2.5    1.5    0.08424   -0.13368
 7.5    2.5    0.5   -0.07108   -0.14892
 7.5    2.5   -0.5   -0.14999   -0.01777
 7.5    2.5   -1.5   -0.07613    0.09414
 7.5    2.5   -2.5    0.02750    0.07991
 7.5    2.5   -3.5    0.04953    0.01122
 7.5    2.5   -4.5    0.01789   -0.01854
 7.5    2.5   -5.5   -0.00292   -0.01025
 7.5    2.5   -6.5   -0.00329   -0.00072
 7.5    2.5   -7.5   -0.00042    0.00056
 7.5    1.5    1.5    0.18898    0.00005
 7.5    1.5    0.5    0.10537   -0.16686
 7.5    1.5   -0.5   -0.07763   -0.16306
 7.5    1.5   -1.5   -0.14373   -0.01703
 7.5    1.5   -2.5   -0.06333    0.07872
 7.5    1.5   -3.5    0.02019    0.05727
 7.5    1.5   -4.5    0.03016    0.00629
 7.5    1.5   -5.5    0.00852   -0.00948
 7.5    1.5   -6.5   -0.00137   -0.00379
 7.5    1.5   -7.5   -0.00084   -0.00006
 7.5    0.5    0.5    0.20607    0.00002
 7.5    0.5   -0.5    0.10068   -0.15943
 7.5    0.5   -1.5   -0.06509   -0.13636
 7.5    0.5   -2.5   -0.10476   -0.01204
 7.5    0.5   -3.5   -0.03931    0.04973
 7.5    0.5   -4.5    0.01125    0.03013
 7.5    0.5   -5.5    0.01312    0.00224
 7.5    0.5   -6.5    0.00259   -0.00332
 7.5    0.5   -7.5   -0.00041   -0.00078
 7.5   -0.5   -0.5    0.17255    0.00002
 7.5   -0.5   -1.5    0.07372   -0.11697
 7.5   -0.5   -2.5   -0.04186   -0.08692
 7.5   -0.5   -3.5   -0.05764   -0.00613
 7.5   -0.5   -4.5   -0.01782    0.02340
 7.5   -0.5   -5.5    0.00467    0.01124
 7.5   -0.5   -6.5    0.00383    0.00038
 7.5   -0.5   -7.5    0.00040   -0.00070
 7.5   -1.5   -1.5    0.11078    0.00005
 7.5   -1.5   -2.5    0.04106   -0.06548
 7.5   -1.5   -3.5   -0.02046   -0.04168
 7.5   -1.5   -4.5   -0.02344   -0.00209
 7.5   -1.5   -5.5   -0.00563    0.00794
 7.5   -1.5   -6.5    0.00137    0.00276
 7.5   -1.5   -7.5    0.00064   -0.00003
 7.5   -2.5   -2.5    0.05391    0.00006
 7.5   -2.5   -3.5    0.01708   -0.02752
 7.5   -2.5   -4.5   -0.00745   -0.01463
 7.5   -2.5   -5.5   -0.00676   -0.00038
 7.5   -2.5   -6.5   -0.00112    0.00182
 7.5   -2.5   -7.5    0.00025    0.00037
 7.5   -3.5   -3.5    0.01944    0.00005
 7.5   -3.5   -4.5    0.00513   -0.00842
 7.5   -3.5   -5.5   -0.00195   -0.00358
 7.5   -3.5   -6.5   -0.00128    0.00001
 7.5   -3.5   -7.5   -0.00011    0.00024
 7.5   -4.5   -4.5    0.00498    0.00003
 7.5   -4.5   -5.5    0.00105   -0.00177
 7.5   -4.5   -6.5   -0.00034   -0.00056
 7.5   -4.5   -7.5   -0.00013    0.00002
 7.5   -5.5   -5.5    0.00084    0.00001
 7.5   -5.5   -6.5    0.00013   -0.00023
 7.5   -5.5   -7.5   -0.00003   -0.00005
 7.5   -6.5   -6.5    0.00008    0.00000
 7.5   -6.5   -7.5    0.00001   -0.00001
triangle [[ 0.0001+0.j      0.0001-0.0002j -0.0004-0.0006j -0.0014-0.j     -0.0012+0.0019j  0.0014+0.0028j  0.0037+0.0004j  0.0024-0.003j  -0.0012-0.0034j -0.0028-0.0006j -0.0014+0.0014j  0.0003+0.0012j  0.0006+0.0002j  0.0002-0.0002j -0.    -0.0001j -0.    -0.j    ]
 [ 0.    +0.j      0.001 +0.j      0.0013-0.0023j -0.0025-0.0046j -0.0085-0.0005j -0.0068+0.0096j  0.0054+0.013j   0.0145+0.0025j  0.009 -0.01j   -0.0029-0.0104j -0.0072-0.0021j -0.0034+0.003j   0.0004+0.0023j  0.0009+0.0003j  0.0002-0.0002j -0.    -0.0001j]
 [ 0.    +0.j      0.    +0.j      0.0067+0.j      0.0069-0.0113j -0.0098-0.0192j -0.0297-0.0026j -0.0216+0.0284j  0.0131+0.0349j  0.0334+0.007j   0.019 -0.0197j -0.0046-0.0185j -0.0109-0.0035j -0.0044+0.0038j  0.0005+0.0024j  0.0007+0.0002j  0.0001-0.0001j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.0262+0.0001j  0.0224-0.0361j -0.0259-0.0528j -0.07  -0.0074j -0.0455+0.0577j  0.0224+0.0634j  0.0526+0.0119j  0.0265-0.0267j -0.0053-0.022j  -0.0109-0.0035j -0.0035+0.0032j  0.0004+0.0015j  0.0003+0.0001j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0691+0.0001j  0.0507-0.081j  -0.0496-0.103j  -0.1186-0.0136j -0.0685+0.0852j  0.0285+0.0828j  0.0596+0.0138j  0.0259-0.0261j -0.0045-0.0181j -0.0074-0.0021j -0.0017+0.0017j  0.0002+0.0005j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1321+0.0001j  0.0842-0.1337j -0.0711-0.1489j -0.15  -0.0178j -0.0761+0.0941j  0.0275+0.0799j  0.0495+0.0112j  0.0179-0.0185j -0.0029-0.0103j -0.0033-0.0007j -0.0004+0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.189 +0.j      0.1054-0.1669j -0.0776-0.1631j -0.1437-0.017j  -0.0633+0.0787j  0.0202+0.0573j  0.0302+0.0063j  0.0085-0.0095j -0.0014-0.0038j -0.0008-0.0001j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.2061+0.j      0.1007-0.1594j -0.0651-0.1364j -0.1048-0.012j  -0.0393+0.0497j  0.0113+0.0301j  0.0131+0.0022j  0.0026-0.0033j -0.0004-0.0008j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1726+0.j      0.0737-0.117j  -0.0419-0.0869j -0.0576-0.0061j -0.0178+0.0234j  0.0047+0.0112j  0.0038+0.0004j  0.0004-0.0007j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1108+0.0001j  0.0411-0.0655j -0.0205-0.0417j -0.0234-0.0021j -0.0056+0.0079j  0.0014+0.0028j  0.0006-0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0539+0.0001j  0.0171-0.0275j -0.0074-0.0146j -0.0068-0.0004j -0.0011+0.0018j  0.0003+0.0004j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0194+0.0001j  0.0051-0.0084j -0.0019-0.0036j -0.0013+0.j     -0.0001+0.0002j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.005 +0.j      0.0011-0.0018j -0.0003-0.0006j -0.0001+0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0008+0.j      0.0001-0.0002j -0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0001+0.j      0.    -0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j     -0.    -0.j    ]]
full [[ 0.0001+0.j      0.0001-0.0002j -0.0004-0.0006j -0.0014-0.j     -0.0012+0.0019j  0.0014+0.0028j  0.0037+0.0004j  0.0024-0.003j  -0.0012-0.0034j -0.0028-0.0006j -0.0014+0.0014j  0.0003+0.0012j  0.0006+0.0002j  0.0002-0.0002j -0.    -0.0001j -0.    -0.j    ]
 [ 0.0001+0.0002j  0.001 +0.j      0.0013-0.0023j -0.0025-0.0046j -0.0085-0.0005j -0.0068+0.0096j  0.0054+0.013j   0.0145+0.0025j  0.009 -0.01j   -0.0029-0.0104j -0.0072-0.0021j -0.0034+0.003j   0.0004+0.0023j  0.0009+0.0003j  0.0002-0.0002j -0.    -0.0001j]
 [-0.0004+0.0006j  0.0013+0.0023j  0.0067+0.j      0.0069-0.0113j -0.0098-0.0192j -0.0297-0.0026j -0.0216+0.0284j  0.0131+0.0349j  0.0334+0.007j   0.019 -0.0197j -0.0046-0.0185j -0.0109-0.0035j -0.0044+0.0038j  0.0005+0.0024j  0.0007+0.0002j  0.0001-0.0001j]
 [-0.0014+0.j     -0.0025+0.0046j  0.0069+0.0113j  0.0262+0.j      0.0224-0.0361j -0.0259-0.0528j -0.07  -0.0074j -0.0455+0.0577j  0.0224+0.0634j  0.0526+0.0119j  0.0265-0.0267j -0.0053-0.022j  -0.0109-0.0035j -0.0035+0.0032j  0.0004+0.0015j  0.0003+0.0001j]
 [-0.0012-0.0019j -0.0085+0.0005j -0.0098+0.0192j  0.0224+0.0361j  0.0691+0.j      0.0507-0.081j  -0.0496-0.103j  -0.1186-0.0136j -0.0685+0.0852j  0.0285+0.0828j  0.0596+0.0138j  0.0259-0.0261j -0.0045-0.0181j -0.0074-0.0021j -0.0017+0.0017j  0.0002+0.0005j]
 [ 0.0014-0.0028j -0.0068-0.0096j -0.0297+0.0026j -0.0259+0.0528j  0.0507+0.081j   0.1321+0.j      0.0842-0.1337j -0.0711-0.1489j -0.15  -0.0178j -0.0761+0.0941j  0.0275+0.0799j  0.0495+0.0112j  0.0179-0.0185j -0.0029-0.0103j -0.0033-0.0007j -0.0004+0.0006j]
 [ 0.0037-0.0004j  0.0054-0.013j  -0.0216-0.0284j -0.07  +0.0074j -0.0496+0.103j   0.0842+0.1337j  0.189 +0.j      0.1054-0.1669j -0.0776-0.1631j -0.1437-0.017j  -0.0633+0.0787j  0.0202+0.0573j  0.0302+0.0063j  0.0085-0.0095j -0.0014-0.0038j -0.0008-0.0001j]
 [ 0.0024+0.003j   0.0145-0.0025j  0.0131-0.0349j -0.0455-0.0577j -0.1186+0.0136j -0.0711+0.1489j  0.1054+0.1669j  0.2061+0.j      0.1007-0.1594j -0.0651-0.1364j -0.1048-0.012j  -0.0393+0.0497j  0.0113+0.0301j  0.0131+0.0022j  0.0026-0.0033j -0.0004-0.0008j]
 [-0.0012+0.0034j  0.009 +0.01j    0.0334-0.007j   0.0224-0.0634j -0.0685-0.0852j -0.15  +0.0178j -0.0776+0.1631j  0.1007+0.1594j  0.1726+0.j      0.0737-0.117j  -0.0419-0.0869j -0.0576-0.0061j -0.0178+0.0234j  0.0047+0.0112j  0.0038+0.0004j  0.0004-0.0007j]
 [-0.0028+0.0006j -0.0029+0.0104j  0.019 +0.0197j  0.0526-0.0119j  0.0285-0.0828j -0.0761-0.0941j -0.1437+0.017j  -0.0651+0.1364j  0.0737+0.117j   0.1108+0.j      0.0411-0.0655j -0.0205-0.0417j -0.0234-0.0021j -0.0056+0.0079j  0.0014+0.0028j  0.0006-0.j    ]
 [-0.0014-0.0014j -0.0072+0.0021j -0.0046+0.0185j  0.0265+0.0267j  0.0596-0.0138j  0.0275-0.0799j -0.0633-0.0787j -0.1048+0.012j  -0.0419+0.0869j  0.0411+0.0655j  0.0539+0.j      0.0171-0.0275j -0.0074-0.0146j -0.0068-0.0004j -0.0011+0.0018j  0.0003+0.0004j]
 [ 0.0003-0.0012j -0.0034-0.003j  -0.0109+0.0035j -0.0053+0.022j   0.0259+0.0261j  0.0495-0.0112j  0.0202-0.0573j -0.0393-0.0497j -0.0576+0.0061j -0.0205+0.0417j  0.0171+0.0275j  0.0194+0.j      0.0051-0.0084j -0.0019-0.0036j -0.0013+0.j     -0.0001+0.0002j]
 [ 0.0006-0.0002j  0.0004-0.0023j -0.0044-0.0038j -0.0109+0.0035j -0.0045+0.0181j  0.0179+0.0185j  0.0302-0.0063j  0.0113-0.0301j -0.0178-0.0234j -0.0234+0.0021j -0.0074+0.0146j  0.0051+0.0084j  0.005 +0.j      0.0011-0.0018j -0.0003-0.0006j -0.0001+0.j    ]
 [ 0.0002+0.0002j  0.0009-0.0003j  0.0005-0.0024j -0.0035-0.0032j -0.0074+0.0021j -0.0029+0.0103j  0.0085+0.0095j  0.0131-0.0022j  0.0047-0.0112j -0.0056-0.0079j -0.0068+0.0004j -0.0019+0.0036j  0.0011+0.0018j  0.0008+0.j      0.0001-0.0002j -0.    -0.j    ]
 [-0.    +0.0001j  0.0002+0.0002j  0.0007-0.0002j  0.0004-0.0015j -0.0017-0.0017j -0.0033+0.0007j -0.0014+0.0038j  0.0026+0.0033j  0.0038-0.0004j  0.0014-0.0028j -0.0011-0.0018j -0.0013-0.j     -0.0003+0.0006j  0.0001+0.0002j  0.0001+0.j      0.    -0.j    ]
 [-0.    +0.j     -0.    +0.0001j  0.0001+0.0001j  0.0003-0.0001j  0.0002-0.0005j -0.0004-0.0006j -0.0008+0.0001j -0.0004+0.0008j  0.0004+0.0007j  0.0006+0.j      0.0003-0.0004j -0.0001-0.0002j -0.0001-0.j     -0.    +0.j      0.    +0.j     -0.    +0.j    ]]
Sum of c^2 0.9928642627648273
Thu Apr 17 13:55:39 PDT 2025
