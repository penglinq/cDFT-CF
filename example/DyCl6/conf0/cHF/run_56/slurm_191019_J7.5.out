Currently Loaded Modulefiles:
 1) gmp/6.2.1-gcc-13.2.0-lcnhyse <aL>             
 2) mpfr/4.2.0-gcc-13.2.0-yy2fkq5 <aL>            
 3) mpc/1.3.1-gcc-13.2.0-5kgoftq <aL>             
 4) zlib-ng/2.1.3-gcc-13.2.0-jetnfwa <aL>         
 5) zstd/1.5.5-gcc-13.2.0-t2lua3l <aL>            
 6) gcc/13.2.0-gcc-13.2.0-w55nxkl                 
 7) cmake/3.20.2-gcc-13.2.0-rp74vpv               
 8) libfabric/1.18.1-gcc-13.2.0-bijxar4 <aL>      
 9) numactl/2.0.14-gcc-13.2.0-etkf74e <aL>        
10) openssh/8.7p1-gcc-13.2.0-g55xmkx <aL>         
11) slurm/22.05.6-gcc-13.2.0-tchsn6y <aL>         
12) openmpi/4.1.5-gcc-13.2.0-24q3ap2              
13) libpciaccess/0.17-gcc-13.2.0-r2cijnn <aL>     
14) libiconv/1.17-gcc-13.2.0-ntov4te <aL>         
15) xz/5.4.1-gcc-13.2.0-4xkm5xo <aL>              
16) libxml2/2.10.3-gcc-13.2.0-fr6jcjz <aL>        
17) ncurses/6.4-gcc-13.2.0-4o2yj6n <aL>           
18) hwloc/2.9.1-gcc-13.2.0-gzvfolk <aL>           
19) intel-tbb/2021.9.0-gcc-13.2.0-6nwk3ml <aL>    
20) intel-oneapi-mkl/2023.2.0-gcc-13.2.0-ohvyk7g  

Key:
<module-tag>  <aL>=auto-loaded  
/central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF
Thu Apr 17 13:18:52 PDT 2025
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
hpc-92-21.cm.cluster
--------------------------------------------------------------------------
WARNING: There was an error initializing an OpenFabrics device.

  Local host:   hpc-92-21
  Local device: mlx5_0
--------------------------------------------------------------------------
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 

Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 
Apr 17 13:18:54 ####### 
                ####### libDMET   version 0.5
                ####### A periodic DMET library for lattice model and realistic solid.
                ####### 

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      numpy 1.26.0  scipy 1.11.3
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
#INFO: ******************** input file end ********************


PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] num. atoms = 7
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************

'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************



[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


nuclear repulsion = 1868.38919656687
number of shells = 84
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
nuclear repulsion = 1868.38919656687
CPU time:         0.95
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

number of shells = 84
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    [CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************

[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[CONFIG] conf_file None
[INPUT] verbose = 4
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.92
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] num. atoms = 7
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
nuclear repulsion = 1868.38919656687
number of shells = 84
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
N_elec (88, 83), N_ao 198
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
ecp = {}
CPU time:         0.94
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0


nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
nuclear repulsion = 1868.38919656687
N_elec (88, 83), N_ao 198
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
N_elec (88, 83), N_ao 198
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
[INPUT] charge = -3
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
#INFO: ******************** input file end ********************


[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
      '''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0


:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
  data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
nuclear repulsion = 1868.38919656687
number of shells = 84
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
ecp = {}
CPU time:         0.94
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
N_elec (88, 83), N_ao 198
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
nuclear repulsion = 1868.38919656687
number of shells = 84
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
N_elec (88, 83), N_ao 198
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6nuclear repulsion = 1868.38919656687
number of shells = 84
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


number of NR pGTOs = 449
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

N_elec (88, 83), N_ao 198
[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
number of shells = 84
N_elec (88, 83), N_ao 198
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
N_elec (88, 83), N_ao 198
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
N_elec (88, 83), N_ao 198
nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.95
N_elec (88, 83), N_ao 198
#INFO: **** input file is /central/groups/changroup/members/lppeng/holmium/run/paper_final/run_Dy/conf7/cHF/run_56/get_JM.py ****
'''
Expand a Slater Determinant in eigenfunctions of J amd Jz
'''
import pyscf
from functools import reduce
from pyscf import scf, lib, lo, symm, gto
import os, sys
import numpy as np
import scipy.linalg as la
import scipy
from mpi4py import MPI
comm = MPI.COMM_WORLD
mpirank = comm.Get_rank()
mpisize = comm.Get_size()
log = lib.logger.Logger(sys.stdout, 4)
np.set_printoptions(precision=4, threshold=sys.maxsize, linewidth=380, suppress=True)

if __name__ == "__main__":
    from pyscf import gto, scf, dft, lib
    from pyscf.lib import chkfile
    from stevens import project
    from stevens.momentum import get_mj

    # system input
    geometry = 'DyCl6' # The name of geometry file minus ".xyz"
                       # Make sure first atom is the central magnetic atom 
    spin = 5 # number of unpaired electrons in a unit cell
    charge = -3 # charge of the molecule or a unit cell
    basis = {'default': '631g', 'Dy': 'sarc-dkh'} # specify basis for all elements here
    max_memory = 6000 # in the unit of MB. Recommend: memory available on a node - 10000 MB

    # other parameter
    chkfname = 'constrained_chkfile.chk'  # load PySCF cHF/DFT solution 
    lo_chkfname = '../../UHF/uhf_gs_%s_lo.h5'%geometry  
    atom_index = 0 # the index of central lanthanide atom
    ao_shell = 'f'
    N_grid = (19,10,19) 
    max_J = 7.5
    max_J_only = True
    project_type = 'full' # "spin" (S), "orb" (L), or "full" (J)
    diag_only = False

    # set up system
    if os.path.isfile('../../' + geometry + ".xyz"):
        mol = gto.M(
            atom = '../../' + geometry + ".xyz",
            basis = basis,
            verbose = 4,
            spin = spin,
            charge = charge,
            max_memory = max_memory,
            )
        mol.set_common_origin(mol._atom[atom_index][1])
    else:
        raise ValueError("No .xyz file available!")
    log.info("N_elec %s, N_ao %s"%(mol.nelec, mol.nao))

    # load cHF solution
    gmf = scf.GHF(mol).x2c()
    if chkfname is not None and os.path.isfile(chkfname):
        data = chkfile.load(chkfname, 'scf')
        gmf.__dict__.update(data)
    else: 
        gmf.chkfile = geometry + '.chk'
        gmf.kernel()
    if mpirank == 0:
        gmf.analyze(with_meta_lowdin=True)
        dm = gmf.make_rdm1()
        print("S vector", get_mj(mol, dm, include_L=False))
        print("L vector", get_mj(mol, dm, include_S=False))
        print("J vector", get_mj(mol, dm))
    
    # calculate JM projection
    comm.Barrier()
    proj = project.Project(mol, gmf, atom_index=atom_index, ao_shell=ao_shell, spin_separate=False, \
            N_grid=N_grid, lo_chkfname=lo_chkfname)

    c2_sum = 0
    if mpirank == 0:
        print("  %s     M     c^2  "%({"spin": "S", "orb": "L", "full": "J"}[project_type]))
    if project_type in ["spin", "full"] and abs(mol.spin%2) > 1e-4: 
        # Scan half-integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J))+0.5, 0, -1)
    else:
        # Scan integer J. The rest is always 0.
        J_range = np.arange(int(np.floor(max_J)), -0.5, -1)
    if max_J_only:
        J_range = J_range[:1]
    c2_Jmk = [] 
    for J in J_range:
        for m in np.arange(J,-J-1,-1):
            for k in np.arange(J,-J-1,-1):
                if (diag_only and np.abs(k-m) > 1e-10) or k-m > 1e-10: 
                    res = 0
                else:
                    # S: proj='spin'
                    # L: proj='orb'
                    # J: proj='full'
                    res = proj.get_proj_ovlp(J=J, m=m, k=k, proj=project_type, N_alpha=N_grid[0], N_beta=N_grid[1], \
                            N_gamma=N_grid[2], verbose=0)
                if J == max(J_range):
                    c2_Jmk.append(res) 
                if mpirank == 0 and la.norm(res) > 1e-5:
                    if abs(res.imag) > 1e-6:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f   %8.5f"%(J,m,k, res.real, res.imag))
                    else:
                        print(" %3.1f   %4.1f   %4.1f   %8.5f"%(J,m,k, res.real))
                    if np.abs(m-k) < 1e-6:
                        c2_sum += res.real
    if mpirank == 0:
        c2_Jmk = np.array(c2_Jmk, dtype=complex).reshape((int(2*max(J_range)+1), int(2*max(J_range)+1)))
        print('triangle', c2_Jmk)
        c2_Jmk[np.tril_indices(len(c2_Jmk), -1)] = c2_Jmk.conj().T[np.tril_indices(len(c2_Jmk), -1)]
        c2_Jmk[np.diag_indices(len(c2_Jmk))] = c2_Jmk[np.diag_indices(len(c2_Jmk))].real # c*c is real 
        print('full', c2_Jmk)
        np.save('c2_Jmk.npy', c2_Jmk)
        print("Sum of c^2", c2_sum)



    
    
#INFO: ******************** input file end ********************


System: uname_result(system='Linux', node='hpc-92-21.cm.cluster', release='5.14.0-362.24.1.el9_3.x86_64', version='#1 SMP PREEMPT_DYNAMIC Thu Feb 15 07:18:13 EST 2024', machine='x86_64')  Threads 1
Python 3.11.6 | packaged by conda-forge | (main, Oct  3 2023, 10:40:35) [GCC 12.3.0]
numpy 1.26.0  scipy 1.11.3
Date: Thu Apr 17 13:18:55 2025
PySCF version 2.5.0
PySCF path  /home/lppeng/anaconda3/envs/nerscV25/lib/python3.11/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 4
[INPUT] num. atoms = 7
[INPUT] num. electrons = 171
[INPUT] charge = -3
[INPUT] spin (= nelec alpha-beta = 2S) = 5
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Dy     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  2 Cl     2.724000000000   0.000000000000   0.000000000000 AA    5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  3 Cl    -2.724000000000   0.000000000000   0.000000000000 AA   -5.147613963315   0.000000000000   0.000000000000 Bohr   0.0
[INPUT]  4 Cl     0.000000000000   2.724000000000   0.000000000000 AA    0.000000000000   5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  5 Cl     0.000000000000  -2.724000000000   0.000000000000 AA    0.000000000000  -5.147613963315   0.000000000000 Bohr   0.0
[INPUT]  6 Cl     0.000000000000   0.000000000000   2.724000000000 AA    0.000000000000   0.000000000000   5.147613963315 Bohr   0.0
[INPUT]  7 Cl     0.000000000000   0.000000000000  -2.724000000000 AA    0.000000000000   0.000000000000  -5.147613963315 Bohr   0.0

nuclear repulsion = 1868.38919656687
number of shells = 84
number of NR pGTOs = 449
number of NR cGTOs = 198
basis = {'default': '631g', 'Dy': 'sarc-dkh'}
ecp = {}
CPU time:         0.94
N_elec (88, 83), N_ao 198
**** MO energy ****
MO #1   energy= -1986.50516327186  occ= 1
MO #2   energy= -1986.50505067786  occ= 1
MO #3   energy= -335.744309813009  occ= 1
MO #4   energy= -335.743848284341  occ= 1
MO #5   energy= -318.560575571055  occ= 1
MO #6   energy= -318.560313504329  occ= 1
MO #7   energy= -288.739597357411  occ= 1
MO #8   energy= -288.739222779161  occ= 1
MO #9   energy= -288.731454604247  occ= 1
MO #10  energy= -288.731330901011  occ= 1
MO #11  energy= -105.084102569217  occ= 1
MO #12  energy= -105.084080936204  occ= 1
MO #13  energy= -105.08396267182   occ= 1
MO #14  energy= -105.08394101751   occ= 1
MO #15  energy= -105.081705867664  occ= 1
MO #16  energy= -105.081702202962  occ= 1
MO #17  energy= -105.081578300979  occ= 1
MO #18  energy= -105.081574637625  occ= 1
MO #19  energy= -105.081539017991  occ= 1
MO #20  energy= -105.081519059584  occ= 1
MO #21  energy= -105.081411409594  occ= 1
MO #22  energy= -105.081391433877  occ= 1
MO #23  energy= -77.0766495404213  occ= 1
MO #24  energy= -76.9571230887141  occ= 1
MO #25  energy= -69.5781208931243  occ= 1
MO #26  energy= -69.5595707936866  occ= 1
MO #27  energy= -63.214881232467   occ= 1
MO #28  energy= -63.2056717175699  occ= 1
MO #29  energy= -63.1305092594292  occ= 1
MO #30  energy= -63.0451477301772  occ= 1
MO #31  energy= -50.7715132718685  occ= 1
MO #32  energy= -50.7676225628128  occ= 1
MO #33  energy= -50.7598822611115  occ= 1
MO #34  energy= -50.7374419174015  occ= 1
MO #35  energy= -49.1958926505219  occ= 1
MO #36  energy= -49.1795602426495  occ= 1
MO #37  energy= -49.1678147761563  occ= 1
MO #38  energy= -49.0955250327146  occ= 1
MO #39  energy= -49.0499218782982  occ= 1
MO #40  energy= -48.9959538906372  occ= 1
MO #41  energy= -16.5559751795267  occ= 1
MO #42  energy= -16.2410445410323  occ= 1
MO #43  energy= -13.4591015435809  occ= 1
MO #44  energy= -13.4139877156836  occ= 1
MO #45  energy= -12.0551919563248  occ= 1
MO #46  energy= -12.0153213754954  occ= 1
MO #47  energy= -11.819050419489   occ= 1
MO #48  energy= -11.6602047225566  occ= 1
MO #49  energy= -10.4911842197222  occ= 1
MO #50  energy= -10.4911628312714  occ= 1
MO #51  energy= -10.4910315849323  occ= 1
MO #52  energy= -10.4910101747571  occ= 1
MO #53  energy= -10.4887164402241  occ= 1
MO #54  energy= -10.4887146378625  occ= 1
MO #55  energy= -10.4885772329827  occ= 1
MO #56  energy= -10.4885754334149  occ= 1
MO #57  energy= -10.4885510836614  occ= 1
MO #58  energy= -10.4885313941602  occ= 1
MO #59  energy= -10.4884118807937  occ= 1
MO #60  energy= -10.488392173551   occ= 1
MO #61  energy= -7.94831690051104  occ= 1
MO #62  energy= -7.94829546713498  occ= 1
MO #63  energy= -7.94821934352124  occ= 1
MO #64  energy= -7.94819789884167  occ= 1
MO #65  energy= -7.9458909025397   occ= 1
MO #66  energy= -7.94588909845128  occ= 1
MO #67  energy= -7.94575058248845  occ= 1
MO #68  energy= -7.94574877630234  occ= 1
MO #69  energy= -7.94572510214035  occ= 1
MO #70  energy= -7.94570537885064  occ= 1
MO #71  energy= -7.94558472526139  occ= 1
MO #72  energy= -7.94556498168779  occ= 1
MO #73  energy= -7.88046388310452  occ= 1
MO #74  energy= -7.88044236666178  occ= 1
MO #75  energy= -7.88018968495966  occ= 1
MO #76  energy= -7.88016812732247  occ= 1
MO #77  energy= -7.87954223836285  occ= 1
MO #78  energy= -7.87952026801867  occ= 1
MO #79  energy= -7.87942560567326  occ= 1
MO #80  energy= -7.87940361001488  occ= 1
MO #81  energy= -7.87799240149254  occ= 1
MO #82  energy= -7.87798975721792  occ= 1
MO #83  energy= -7.87782528059476  occ= 1
MO #84  energy= -7.8778054671136   occ= 1
MO #85  energy= -7.87772828229866  occ= 1
MO #86  energy= -7.87772561985094  occ= 1
MO #87  energy= -7.87756106507459  occ= 1
MO #88  energy= -7.87754121226979  occ= 1
MO #89  energy= -7.87705214697017  occ= 1
MO #90  energy= -7.87704694276037  occ= 1
MO #91  energy= -7.8770360029818   occ= 1
MO #92  energy= -7.87703080279354  occ= 1
MO #93  energy= -7.87688299752858  occ= 1
MO #94  energy= -7.87687117551386  occ= 1
MO #95  energy= -7.87686266109125  occ= 1
MO #96  energy= -7.87685082586322  occ= 1
MO #97  energy= -7.14116089960722  occ= 1
MO #98  energy= -7.1399504267877   occ= 1
MO #99  energy= -7.11073054703424  occ= 1
MO #100 energy= -7.04894087283023  occ= 1
MO #101 energy= -6.81784014744361  occ= 1
MO #102 energy= -6.77079171033942  occ= 1
MO #103 energy= -6.6101414978958   occ= 1
MO #104 energy= -6.39863009340639  occ= 1
MO #105 energy= -6.33389052816947  occ= 1
MO #106 energy= -6.23743386507647  occ= 1
MO #107 energy= -2.38420036247783  occ= 1
MO #108 energy= -2.26751305713567  occ= 1
MO #109 energy= -1.41520857047951  occ= 1
MO #110 energy= -1.41181140467677  occ= 1
MO #111 energy= -1.2207720413652   occ= 1
MO #112 energy= -1.21514145829774  occ= 1
MO #113 energy= -1.17892106322232  occ= 1
MO #114 energy= -1.13390519099802  occ= 1
MO #115 energy= -0.953250319760627 occ= 1
MO #116 energy= -0.952666885729215 occ= 1
MO #117 energy= -0.944976606761639 occ= 1
MO #118 energy= -0.944096158164668 occ= 1
MO #119 energy= -0.943309224269232 occ= 1
MO #120 energy= -0.942410763849229 occ= 1
MO #121 energy= -0.942298403233903 occ= 1
MO #122 energy= -0.941761988806719 occ= 1
MO #123 energy= -0.937362213701822 occ= 1
MO #124 energy= -0.936589306280377 occ= 1
MO #125 energy= -0.936288952925475 occ= 1
MO #126 energy= -0.932840545123764 occ= 1
MO #127 energy= -0.858932786028477 occ= 1
MO #128 energy= -0.854389414497651 occ= 1
MO #129 energy= -0.837617579576768 occ= 1
MO #130 energy= -0.81523378912393  occ= 1
MO #131 energy= -0.780599490051051 occ= 1
MO #132 energy= -0.777580479049016 occ= 1
MO #133 energy= -0.727963914492958 occ= 1
MO #134 energy= -0.631640191232977 occ= 1
MO #135 energy= -0.617052715200181 occ= 1
MO #136 energy= -0.406348065608477 occ= 1
MO #137 energy= -0.405155556427238 occ= 1
MO #138 energy= -0.383453358663285 occ= 1
MO #139 energy= -0.382215104212178 occ= 1
MO #140 energy= -0.380139929551591 occ= 1
MO #141 energy= -0.379834427750492 occ= 1
MO #142 energy= -0.372474502141751 occ= 1
MO #143 energy= -0.372124390849915 occ= 1
MO #144 energy= -0.371351306432672 occ= 1
MO #145 energy= -0.371297055778473 occ= 1
MO #146 energy= -0.370506794330469 occ= 1
MO #147 energy= -0.370351656950621 occ= 1
MO #148 energy= -0.368677596059145 occ= 1
MO #149 energy= -0.36837891389759  occ= 1
MO #150 energy= -0.368244530634363 occ= 1
MO #151 energy= -0.368208192812845 occ= 1
MO #152 energy= -0.367595383476955 occ= 1
MO #153 energy= -0.366118071222127 occ= 1
MO #154 energy= -0.343401705120261 occ= 1
MO #155 energy= -0.342718761566504 occ= 1
MO #156 energy= -0.341277930356028 occ= 1
MO #157 energy= -0.341159054515488 occ= 1
MO #158 energy= -0.340611753688638 occ= 1
MO #159 energy= -0.340342188631224 occ= 1
MO #160 energy= -0.338131702943834 occ= 1
MO #161 energy= -0.337977759662498 occ= 1
MO #162 energy= -0.335432485803848 occ= 1
MO #163 energy= -0.335040623180665 occ= 1
MO #164 energy= -0.334216150731079 occ= 1
MO #165 energy= -0.333669954710656 occ= 1
MO #166 energy= -0.327150092726073 occ= 1
MO #167 energy= -0.326910398731398 occ= 1
MO #168 energy= -0.324692021789585 occ= 1
MO #169 energy= -0.324205637354188 occ= 1
MO #170 energy= -0.323705641041038 occ= 1
MO #171 energy= -0.323412711393986 occ= 1
MO #172 energy= 0.122833023203462  occ= 0
MO #173 energy= 0.12288352637158   occ= 0
MO #174 energy= 0.122992365455115  occ= 0
MO #175 energy= 0.123069104057818  occ= 0
MO #176 energy= 0.12317668503131   occ= 0
MO #177 energy= 0.123273676165281  occ= 0
MO #178 energy= 0.129515424674955  occ= 0
MO #179 energy= 0.129521830069015  occ= 0
MO #180 energy= 0.129785149831167  occ= 0
MO #181 energy= 0.129792596250277  occ= 0
MO #182 energy= 0.129984716201429  occ= 0
MO #183 energy= 0.12998542749637   occ= 0
MO #184 energy= 0.133450331900109  occ= 0
MO #185 energy= 0.133555181039538  occ= 0
MO #186 energy= 0.15332833987383   occ= 0
MO #187 energy= 0.1538328953027    occ= 0
MO #188 energy= 0.153957897432263  occ= 0
MO #189 energy= 0.154244236341978  occ= 0
MO #190 energy= 0.205857857101632  occ= 0
MO #191 energy= 0.209346946322232  occ= 0
MO #192 energy= 0.215693243930318  occ= 0
MO #193 energy= 0.222866273278553  occ= 0
MO #194 energy= 0.232218519180659  occ= 0
MO #195 energy= 0.236933687294025  occ= 0
MO #196 energy= 0.287761121290334  occ= 0
MO #197 energy= 0.296615573488788  occ= 0
MO #198 energy= 0.296877817069866  occ= 0
MO #199 energy= 0.298344531795472  occ= 0
MO #200 energy= 0.298486109360783  occ= 0
MO #201 energy= 0.298893545326421  occ= 0
MO #202 energy= 0.298968239697246  occ= 0
MO #203 energy= 0.304160068140724  occ= 0
MO #204 energy= 0.310362111944507  occ= 0
MO #205 energy= 0.312340275960383  occ= 0
MO #206 energy= 0.321140911620737  occ= 0
MO #207 energy= 0.323459671478823  occ= 0
MO #208 energy= 0.337142334386084  occ= 0
MO #209 energy= 0.337560103592754  occ= 0
MO #210 energy= 0.338418106026066  occ= 0
MO #211 energy= 0.339147335662901  occ= 0
MO #212 energy= 0.340909048241226  occ= 0
MO #213 energy= 0.341452756862663  occ= 0
MO #214 energy= 0.34305554838842   occ= 0
MO #215 energy= 0.344562937513182  occ= 0
MO #216 energy= 0.348688131424676  occ= 0
MO #217 energy= 0.351867538466721  occ= 0
MO #218 energy= 0.404251982092327  occ= 0
MO #219 energy= 0.411541555997484  occ= 0
MO #220 energy= 0.43780147771386   occ= 0
MO #221 energy= 0.443246122148816  occ= 0
MO #222 energy= 0.475837365936447  occ= 0
MO #223 energy= 0.475992758398898  occ= 0
MO #224 energy= 0.483799302022003  occ= 0
MO #225 energy= 0.491933241009282  occ= 0
MO #226 energy= 0.495910367046289  occ= 0
MO #227 energy= 0.499364585312367  occ= 0
MO #228 energy= 0.510754378935636  occ= 0
MO #229 energy= 0.516332801162878  occ= 0
MO #230 energy= 0.54757096342117   occ= 0
MO #231 energy= 0.549593712611376  occ= 0
MO #232 energy= 0.5790752317266    occ= 0
MO #233 energy= 0.605806730740496  occ= 0
MO #234 energy= 0.607848060992588  occ= 0
MO #235 energy= 0.608172250504168  occ= 0
MO #236 energy= 0.612019048472782  occ= 0
MO #237 energy= 0.621439371733129  occ= 0
MO #238 energy= 0.628049579104233  occ= 0
MO #239 energy= 0.628931004770456  occ= 0
MO #240 energy= 0.63135975818473   occ= 0
MO #241 energy= 0.635114120855165  occ= 0
MO #242 energy= 0.665562706542219  occ= 0
MO #243 energy= 0.672371102730275  occ= 0
MO #244 energy= 0.68815860796473   occ= 0
MO #245 energy= 0.741925318158796  occ= 0
MO #246 energy= 0.746159372521815  occ= 0
MO #247 energy= 0.74841485862979   occ= 0
MO #248 energy= 0.750245207149147  occ= 0
MO #249 energy= 0.770789393128836  occ= 0
MO #250 energy= 0.771039473661113  occ= 0
MO #251 energy= 0.773407229996016  occ= 0
MO #252 energy= 0.77711680507837   occ= 0
MO #253 energy= 0.777211361597435  occ= 0
MO #254 energy= 0.777671906495391  occ= 0
MO #255 energy= 0.777704149109834  occ= 0
MO #256 energy= 0.777767206092858  occ= 0
MO #257 energy= 0.78054645452362   occ= 0
MO #258 energy= 0.78059101001553   occ= 0
MO #259 energy= 0.782892449273336  occ= 0
MO #260 energy= 0.792886363501962  occ= 0
MO #261 energy= 0.801379559448034  occ= 0
MO #262 energy= 0.801480288284237  occ= 0
MO #263 energy= 0.804924234099669  occ= 0
MO #264 energy= 0.805390712617011  occ= 0
MO #265 energy= 0.805629887972824  occ= 0
MO #266 energy= 0.806298115773547  occ= 0
MO #267 energy= 0.806480936788321  occ= 0
MO #268 energy= 0.809982479087242  occ= 0
MO #269 energy= 0.867170657287218  occ= 0
MO #270 energy= 0.8672689435739    occ= 0
MO #271 energy= 0.869805523484857  occ= 0
MO #272 energy= 0.869994270951415  occ= 0
MO #273 energy= 0.870518533009368  occ= 0
MO #274 energy= 0.870628493394985  occ= 0
MO #275 energy= 0.932999286790214  occ= 0
MO #276 energy= 0.933909543254845  occ= 0
MO #277 energy= 0.934101893745305  occ= 0
MO #278 energy= 0.934193156604712  occ= 0
MO #279 energy= 0.937678522717233  occ= 0
MO #280 energy= 0.938098034467907  occ= 0
MO #281 energy= 1.01784609935388   occ= 0
MO #282 energy= 1.01874031101062   occ= 0
MO #283 energy= 1.0200532865496    occ= 0
MO #284 energy= 1.02118614719392   occ= 0
MO #285 energy= 1.02389641517168   occ= 0
MO #286 energy= 1.02538011780484   occ= 0
MO #287 energy= 1.03029702939031   occ= 0
MO #288 energy= 1.04194664692293   occ= 0
MO #289 energy= 1.0421089504284    occ= 0
MO #290 energy= 1.04590305379594   occ= 0
MO #291 energy= 1.09191412182972   occ= 0
MO #292 energy= 1.09200040844325   occ= 0
MO #293 energy= 1.09432470626485   occ= 0
MO #294 energy= 1.094478454107     occ= 0
MO #295 energy= 1.09478879598072   occ= 0
MO #296 energy= 1.09527079896149   occ= 0
MO #297 energy= 1.10627678550282   occ= 0
MO #298 energy= 1.11371097802617   occ= 0
MO #299 energy= 1.12190075170619   occ= 0
MO #300 energy= 1.12551712048417   occ= 0
MO #301 energy= 1.3256234597693    occ= 0
MO #302 energy= 1.33046697312577   occ= 0
MO #303 energy= 1.37049438820209   occ= 0
MO #304 energy= 1.38326952023914   occ= 0
MO #305 energy= 1.53166536977789   occ= 0
MO #306 energy= 1.53723261539512   occ= 0
MO #307 energy= 1.55589559951821   occ= 0
MO #308 energy= 1.58926233474231   occ= 0
MO #309 energy= 1.59345369614639   occ= 0
MO #310 energy= 1.60581623997715   occ= 0
MO #311 energy= 1.60730414864948   occ= 0
MO #312 energy= 1.6132871377226    occ= 0
MO #313 energy= 1.61680056384554   occ= 0
MO #314 energy= 1.62095554399452   occ= 0
MO #315 energy= 1.62801817275727   occ= 0
MO #316 energy= 1.69143583408408   occ= 0
MO #317 energy= 1.70739349147525   occ= 0
MO #318 energy= 1.71620968522591   occ= 0
MO #319 energy= 1.85673245205956   occ= 0
MO #320 energy= 1.86111615603907   occ= 0
MO #321 energy= 1.88162717012349   occ= 0
MO #322 energy= 1.9206863993963    occ= 0
MO #323 energy= 1.92193273882735   occ= 0
MO #324 energy= 1.93530793342206   occ= 0
MO #325 energy= 2.64933472510814   occ= 0
MO #326 energy= 2.67058884819224   occ= 0
MO #327 energy= 2.67881790531538   occ= 0
MO #328 energy= 2.70122555106375   occ= 0
MO #329 energy= 2.7461871568874    occ= 0
MO #330 energy= 2.76359924054064   occ= 0
MO #331 energy= 2.82361357466201   occ= 0
MO #332 energy= 2.85632857734789   occ= 0
MO #333 energy= 2.89525582393015   occ= 0
MO #334 energy= 2.91815013229311   occ= 0
MO #335 energy= 4.4099971386119    occ= 0
MO #336 energy= 4.46573225985049   occ= 0
MO #337 energy= 5.73124945407409   occ= 0
MO #338 energy= 5.74327500860913   occ= 0
MO #339 energy= 6.24343126664605   occ= 0
MO #340 energy= 6.25329136834575   occ= 0
MO #341 energy= 6.28316341501647   occ= 0
MO #342 energy= 6.34088032367003   occ= 0
MO #343 energy= 11.402910418111    occ= 0
MO #344 energy= 11.4374944648021   occ= 0
MO #345 energy= 11.4471378227837   occ= 0
MO #346 energy= 11.4748497592593   occ= 0
MO #347 energy= 11.7286160428913   occ= 0
MO #348 energy= 11.7688098850712   occ= 0
MO #349 energy= 11.7724175890587   occ= 0
MO #350 energy= 11.8229388358972   occ= 0
MO #351 energy= 11.847423546052    occ= 0
MO #352 energy= 11.9266338738069   occ= 0
MO #353 energy= 16.7877861300557   occ= 0
MO #354 energy= 16.8807707471026   occ= 0
MO #355 energy= 27.9150371998329   occ= 0
MO #356 energy= 27.9374569184135   occ= 0
MO #357 energy= 31.0818369538668   occ= 0
MO #358 energy= 31.1144207589142   occ= 0
MO #359 energy= 31.1331504849708   occ= 0
MO #360 energy= 31.2153059186531   occ= 0
MO #361 energy= 60.4323433451028   occ= 0
MO #362 energy= 60.4413527026285   occ= 0
MO #363 energy= 60.4662564025207   occ= 0
MO #364 energy= 60.4954969662412   occ= 0
MO #365 energy= 62.6199399112294   occ= 0
MO #366 energy= 62.6409977239182   occ= 0
MO #367 energy= 62.6589501217229   occ= 0
MO #368 energy= 62.6718565953013   occ= 0
MO #369 energy= 62.6905068414451   occ= 0
MO #370 energy= 62.7527788530265   occ= 0
MO #371 energy= 71.9742744367427   occ= 0
MO #372 energy= 72.0426661444102   occ= 0
MO #373 energy= 150.734228609763   occ= 0
MO #374 energy= 150.743554029973   occ= 0
MO #375 energy= 165.183622947292   occ= 0
MO #376 energy= 165.201875329642   occ= 0
MO #377 energy= 165.211275322247   occ= 0
MO #378 energy= 165.245750393873   occ= 0
MO #379 energy= 294.47093442805    occ= 0
MO #380 energy= 294.491331063413   occ= 0
MO #381 energy= 690.538509495902   occ= 0
MO #382 energy= 690.539981861906   occ= 0
MO #383 energy= 798.986524670633   occ= 0
MO #384 energy= 798.989036180488   occ= 0
MO #385 energy= 798.996607707376   occ= 0
MO #386 energy= 799.001215402953   occ= 0
MO #387 energy= 1008.64591406571   occ= 0
MO #388 energy= 1008.64993500638   occ= 0
MO #389 energy= 2865.03492304966   occ= 0
MO #390 energy= 2865.03581523609   occ= 0
MO #391 energy= 6964.91717091615   occ= 0
MO #392 energy= 6964.91743572066   occ= 0
MO #393 energy= 14850.4542978009   occ= 0
MO #394 energy= 14850.4543902549   occ= 0
MO #395 energy= 35043.5915872673   occ= 0
MO #396 energy= 35043.5916164131   occ= 0
 ** Mulliken pop alpha/beta on meta-lowdin orthogonal AOs **
 ** Mulliken pop       alpha | beta **
pop of  0 Dy 1s        0.99999 | 0.99999   
pop of  0 Dy 2s        1.00000 | 1.00000   
pop of  0 Dy 3s        1.00000 | 1.00000   
pop of  0 Dy 4s        0.99999 | 0.99999   
pop of  0 Dy 5s        0.99812 | 0.99827   
pop of  0 Dy 6s        0.19746 | 0.19687   
pop of  0 Dy 7s        0.00666 | 0.00650   
pop of  0 Dy 8s        0.00038 | 0.00036   
pop of  0 Dy 9s        0.00024 | 0.00024   
pop of  0 Dy 10s        0.00018 | 0.00017   
pop of  0 Dy 11s        0.00000 | 0.00000   
pop of  0 Dy 12s        0.00001 | 0.00001   
pop of  0 Dy 13s        0.00001 | 0.00001   
pop of  0 Dy 14s        0.00000 | 0.00000   
pop of  0 Dy 15s        0.00000 | 0.00000   
pop of  0 Dy 16s        0.00000 | 0.00000   
pop of  0 Dy 17s        0.00000 | 0.00000   
pop of  0 Dy 18s        0.00000 | 0.00000   
pop of  0 Dy 2px       0.99897 | 0.99897   
pop of  0 Dy 2py       0.99897 | 0.99897   
pop of  0 Dy 2pz       0.99897 | 0.99897   
pop of  0 Dy 3px       0.99875 | 0.99875   
pop of  0 Dy 3py       0.99875 | 0.99875   
pop of  0 Dy 3pz       0.99875 | 0.99875   
pop of  0 Dy 4px       0.99838 | 0.99838   
pop of  0 Dy 4py       0.99838 | 0.99838   
pop of  0 Dy 4pz       0.99838 | 0.99838   
pop of  0 Dy 5px       0.99587 | 0.99604   
pop of  0 Dy 5py       0.99512 | 0.99536   
pop of  0 Dy 5pz       0.99587 | 0.99605   
pop of  0 Dy 6px       0.00646 | 0.00629   
pop of  0 Dy 6py       0.00734 | 0.00710   
pop of  0 Dy 6pz       0.00647 | 0.00629   
pop of  0 Dy 7px       0.00306 | 0.00299   
pop of  0 Dy 7py       0.00346 | 0.00336   
pop of  0 Dy 7pz       0.00307 | 0.00298   
pop of  0 Dy 8px       0.00154 | 0.00153   
pop of  0 Dy 8py       0.00163 | 0.00161   
pop of  0 Dy 8pz       0.00154 | 0.00153   
pop of  0 Dy 9px       0.00069 | 0.00068   
pop of  0 Dy 9py       0.00070 | 0.00070   
pop of  0 Dy 9pz       0.00069 | 0.00068   
pop of  0 Dy 10px       0.00071 | 0.00071   
pop of  0 Dy 10py       0.00070 | 0.00070   
pop of  0 Dy 10pz       0.00071 | 0.00071   
pop of  0 Dy 11px       0.00068 | 0.00068   
pop of  0 Dy 11py       0.00067 | 0.00067   
pop of  0 Dy 11pz       0.00068 | 0.00068   
pop of  0 Dy 12px       0.00059 | 0.00059   
pop of  0 Dy 12py       0.00059 | 0.00059   
pop of  0 Dy 12pz       0.00059 | 0.00059   
pop of  0 Dy 13px       0.00107 | 0.00107   
pop of  0 Dy 13py       0.00107 | 0.00107   
pop of  0 Dy 13pz       0.00107 | 0.00107   
pop of  0 Dy 3dxy      0.99991 | 0.99991   
pop of  0 Dy 3dyz      0.99991 | 0.99991   
pop of  0 Dy 3dz^2     0.99991 | 0.99991   
pop of  0 Dy 3dxz      0.99991 | 0.99991   
pop of  0 Dy 3dx2-y2    0.99991 | 0.99991   
pop of  0 Dy 4dxy      0.99973 | 0.99973   
pop of  0 Dy 4dyz      0.99973 | 0.99973   
pop of  0 Dy 4dz^2     0.99974 | 0.99974   
pop of  0 Dy 4dxz      0.99975 | 0.99975   
pop of  0 Dy 4dx2-y2    0.99971 | 0.99971   
pop of  0 Dy 5dxy      0.01418 | 0.01398   
pop of  0 Dy 5dyz      0.01417 | 0.01399   
pop of  0 Dy 5dz^2     0.03393 | 0.03343   
pop of  0 Dy 5dxz      0.01359 | 0.01347   
pop of  0 Dy 5dx2-y2    0.03521 | 0.03445   
pop of  0 Dy 6dxy      0.00162 | 0.00163   
pop of  0 Dy 6dyz      0.00162 | 0.00163   
pop of  0 Dy 6dz^2     0.00044 | 0.00043   
pop of  0 Dy 6dxz      0.00164 | 0.00165   
pop of  0 Dy 6dx2-y2    0.00052 | 0.00049   
pop of  0 Dy 7dxy      0.00014 | 0.00014   
pop of  0 Dy 7dyz      0.00014 | 0.00014   
pop of  0 Dy 7dz^2     0.00243 | 0.00242   
pop of  0 Dy 7dxz      0.00014 | 0.00014   
pop of  0 Dy 7dx2-y2    0.00251 | 0.00249   
pop of  0 Dy 8dxy      0.00004 | 0.00004   
pop of  0 Dy 8dyz      0.00004 | 0.00004   
pop of  0 Dy 8dz^2     0.00095 | 0.00095   
pop of  0 Dy 8dxz      0.00004 | 0.00004   
pop of  0 Dy 8dx2-y2    0.00097 | 0.00097   
pop of  0 Dy 9dxy      0.00009 | 0.00009   
pop of  0 Dy 9dyz      0.00009 | 0.00009   
pop of  0 Dy 9dz^2     0.00018 | 0.00018   
pop of  0 Dy 9dxz      0.00010 | 0.00010   
pop of  0 Dy 9dx2-y2    0.00017 | 0.00017   
pop of  0 Dy 10dxy      0.00015 | 0.00014   
pop of  0 Dy 10dyz      0.00015 | 0.00014   
pop of  0 Dy 10dz^2     0.00014 | 0.00014   
pop of  0 Dy 10dxz      0.00014 | 0.00014   
pop of  0 Dy 10dx2-y2    0.00014 | 0.00014   
pop of  0 Dy 11dxy      0.00018 | 0.00018   
pop of  0 Dy 11dyz      0.00018 | 0.00018   
pop of  0 Dy 11dz^2     0.00002 | 0.00002   
pop of  0 Dy 11dxz      0.00017 | 0.00017   
pop of  0 Dy 11dx2-y2    0.00002 | 0.00002   
pop of  0 Dy 4f-3      0.62745 | 0.53948   
pop of  0 Dy 4f-2      0.75125 | 0.71298   
pop of  0 Dy 4f-1      0.66452 | 0.63059   
pop of  0 Dy 4f+0      0.69053 | 0.62703   
pop of  0 Dy 4f+1      0.74875 | 0.71309   
pop of  0 Dy 4f+2      0.65113 | 0.56793   
pop of  0 Dy 4f+3      0.58937 | 0.48334   
pop of  0 Dy 5f-3      0.00161 | 0.00148   
pop of  0 Dy 5f-2      0.00076 | 0.00064   
pop of  0 Dy 5f-1      0.00135 | 0.00123   
pop of  0 Dy 5f+0      0.00160 | 0.00149   
pop of  0 Dy 5f+1      0.00103 | 0.00094   
pop of  0 Dy 5f+2      0.00105 | 0.00092   
pop of  0 Dy 5f+3      0.00162 | 0.00148   
pop of  0 Dy 6f-3      0.00199 | 0.00198   
pop of  0 Dy 6f-2      0.00012 | 0.00010   
pop of  0 Dy 6f-1      0.00180 | 0.00179   
pop of  0 Dy 6f+0      0.00216 | 0.00215   
pop of  0 Dy 6f+1      0.00171 | 0.00170   
pop of  0 Dy 6f+2      0.00152 | 0.00150   
pop of  0 Dy 6f+3      0.00198 | 0.00197   
pop of  1 Cl 1s        1.00000 | 1.00000   
pop of  1 Cl 2s        1.00000 | 1.00000   
pop of  1 Cl 3s        0.98077 | 0.98078   
pop of  1 Cl 4s        0.00143 | 0.00141   
pop of  1 Cl 2px       1.00000 | 1.00000   
pop of  1 Cl 2py       1.00000 | 1.00000   
pop of  1 Cl 2pz       1.00000 | 1.00000   
pop of  1 Cl 3px       0.96663 | 0.96693   
pop of  1 Cl 3py       0.99245 | 0.99247   
pop of  1 Cl 3pz       0.99274 | 0.99277   
pop of  1 Cl 4px       0.00189 | 0.00187   
pop of  1 Cl 4py       0.00171 | 0.00171   
pop of  1 Cl 4pz       0.00169 | 0.00168   
pop of  2 Cl 1s        1.00000 | 1.00000   
pop of  2 Cl 2s        1.00000 | 1.00000   
pop of  2 Cl 3s        0.98077 | 0.98078   
pop of  2 Cl 4s        0.00143 | 0.00141   
pop of  2 Cl 2px       1.00000 | 1.00000   
pop of  2 Cl 2py       1.00000 | 1.00000   
pop of  2 Cl 2pz       1.00000 | 1.00000   
pop of  2 Cl 3px       0.96663 | 0.96693   
pop of  2 Cl 3py       0.99245 | 0.99247   
pop of  2 Cl 3pz       0.99274 | 0.99277   
pop of  2 Cl 4px       0.00189 | 0.00187   
pop of  2 Cl 4py       0.00171 | 0.00171   
pop of  2 Cl 4pz       0.00169 | 0.00168   
pop of  3 Cl 1s        1.00000 | 1.00000   
pop of  3 Cl 2s        1.00000 | 1.00000   
pop of  3 Cl 3s        0.98075 | 0.98076   
pop of  3 Cl 4s        0.00150 | 0.00147   
pop of  3 Cl 2px       1.00000 | 1.00000   
pop of  3 Cl 2py       1.00000 | 1.00000   
pop of  3 Cl 2pz       1.00000 | 1.00000   
pop of  3 Cl 3px       0.99256 | 0.99256   
pop of  3 Cl 3py       0.96566 | 0.96601   
pop of  3 Cl 3pz       0.99257 | 0.99256   
pop of  3 Cl 4px       0.00165 | 0.00165   
pop of  3 Cl 4py       0.00191 | 0.00188   
pop of  3 Cl 4pz       0.00165 | 0.00165   
pop of  4 Cl 1s        1.00000 | 1.00000   
pop of  4 Cl 2s        1.00000 | 1.00000   
pop of  4 Cl 3s        0.98075 | 0.98076   
pop of  4 Cl 4s        0.00150 | 0.00147   
pop of  4 Cl 2px       1.00000 | 1.00000   
pop of  4 Cl 2py       1.00000 | 1.00000   
pop of  4 Cl 2pz       1.00000 | 1.00000   
pop of  4 Cl 3px       0.99256 | 0.99256   
pop of  4 Cl 3py       0.96566 | 0.96602   
pop of  4 Cl 3pz       0.99257 | 0.99257   
pop of  4 Cl 4px       0.00165 | 0.00165   
pop of  4 Cl 4py       0.00191 | 0.00188   
pop of  4 Cl 4pz       0.00165 | 0.00165   
pop of  5 Cl 1s        1.00000 | 1.00000   
pop of  5 Cl 2s        1.00000 | 1.00000   
pop of  5 Cl 3s        0.98077 | 0.98078   
pop of  5 Cl 4s        0.00143 | 0.00141   
pop of  5 Cl 2px       1.00000 | 1.00000   
pop of  5 Cl 2py       1.00000 | 1.00000   
pop of  5 Cl 2pz       1.00000 | 1.00000   
pop of  5 Cl 3px       0.99273 | 0.99275   
pop of  5 Cl 3py       0.99243 | 0.99247   
pop of  5 Cl 3pz       0.96660 | 0.96688   
pop of  5 Cl 4px       0.00169 | 0.00168   
pop of  5 Cl 4py       0.00172 | 0.00171   
pop of  5 Cl 4pz       0.00189 | 0.00187   
pop of  6 Cl 1s        1.00000 | 1.00000   
pop of  6 Cl 2s        1.00000 | 1.00000   
pop of  6 Cl 3s        0.98077 | 0.98078   
pop of  6 Cl 4s        0.00143 | 0.00141   
pop of  6 Cl 2px       1.00000 | 1.00000   
pop of  6 Cl 2py       1.00000 | 1.00000   
pop of  6 Cl 2pz       1.00000 | 1.00000   
pop of  6 Cl 3px       0.99273 | 0.99275   
pop of  6 Cl 3py       0.99243 | 0.99247   
pop of  6 Cl 3pz       0.96659 | 0.96687   
pop of  6 Cl 4px       0.00169 | 0.00168   
pop of  6 Cl 4py       0.00171 | 0.00171   
pop of  6 Cl 4pz       0.00189 | 0.00187   
In total            85.72519 | 85.27481  
 ** Mulliken atomic charges   ( Nelec_alpha | Nelec_beta ) **
charge of  0Dy =      2.26893  (    32.09165     31.63942 )
charge of  1Cl =     -0.87892  (     8.93930      8.93962 )
charge of  2Cl =     -0.87892  (     8.93930      8.93962 )
charge of  3Cl =     -0.87677  (     8.93823      8.93853 )
charge of  4Cl =     -0.87678  (     8.93824      8.93854 )
charge of  5Cl =     -0.87878  (     8.93923      8.93954 )
charge of  6Cl =     -0.87877  (     8.93923      8.93954 )
(3, 198, 198) 198
S vector [0.3091+0.j 2.3523-0.j 0.2252-0.j]
(3, 198, 198) 198
L vector [0.6453-0.j 5.0539-0.j 0.4679+0.j]
(3, 198, 198) 198
J vector [0.9544+0.j 7.4062-0.j 0.693 +0.j]
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924
LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

LO diff from identity 0.003969852403580924

WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!


WARN: LO is not orthonormal!

ao_index [ 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317]
ao_labels ['0 Dy 4f-3  ' '0 Dy 4f-2  ' '0 Dy 4f-1  ' '0 Dy 4f+0  ' '0 Dy 4f+1  ' '0 Dy 4f+2  ' '0 Dy 4f+3  ' '0 Dy 5f-3  ' '0 Dy 5f-2  ' '0 Dy 5f-1  ' '0 Dy 5f+0  ' '0 Dy 5f+1  ' '0 Dy 5f+2  ' '0 Dy 5f+3  ' '0 Dy 6f-3  ' '0 Dy 6f-2  ' '0 Dy 6f-1  ' '0 Dy 6f+0  ' '0 Dy 6f+1  ' '0 Dy 6f+2  ' '0 Dy 6f+3  ']
  J     M     c^2  
rank = 0, idx_lst = [ 0 16]
rank = 8, idx_lst = [ 8 24]
rank = 1, idx_lst = [ 1 17]
rank = 4, idx_lst = [ 4 20]
rank = 7, idx_lst = [ 7 23]
rank = 12, idx_lst = [12 28]
rank = 11, idx_lst = [11 27]
rank = 9, idx_lst = [ 9 25]
rank = 14, idx_lst = [14]
rank = 13, idx_lst = [13]
rank = 2, idx_lst = [ 2 18]
rank = 10, idx_lst = [10 26]
rank = 5, idx_lst = [ 5 21]
rank = 6, idx_lst = [ 6 22]
rank = 15, idx_lst = [15]
rank = 3, idx_lst = [ 3 19]
[hpc-92-21.cm.cluster:347696] 15 more processes have sent help message help-mpi-btl-openib.txt / error in device init
[hpc-92-21.cm.cluster:347696] Set MCA parameter "orte_base_help_aggregate" to 0 to see all help / error messages
 7.5    7.5    7.5    0.00012    0.00000
 7.5    7.5    6.5    0.00005    0.00043
 7.5    7.5    5.5   -0.00101    0.00024
 7.5    7.5    4.5   -0.00066   -0.00185
 7.5    7.5    3.5    0.00277   -0.00138
 7.5    7.5    2.5    0.00232    0.00348
 7.5    7.5    1.5   -0.00372    0.00324
 7.5    7.5    0.5   -0.00382   -0.00339
 7.5    7.5   -0.5    0.00262   -0.00385
 7.5    7.5   -1.5    0.00334    0.00168
 7.5    7.5   -2.5   -0.00087    0.00248
 7.5    7.5   -3.5   -0.00158   -0.00034
 7.5    7.5   -4.5    0.00008   -0.00085
 7.5    7.5   -5.5    0.00038   -0.00001
 7.5    7.5   -6.5    0.00001    0.00013
 7.5    7.5   -7.5   -0.00003    0.00001
 7.5    6.5    6.5    0.00149   -0.00001
 7.5    6.5    5.5    0.00043    0.00352
 7.5    6.5    4.5   -0.00650    0.00158
 7.5    6.5    3.5   -0.00371   -0.00988
 7.5    6.5    2.5    0.01263   -0.00666
 7.5    6.5    1.5    0.00970    0.01378
 7.5    6.5    0.5   -0.01287    0.01180
 7.5    6.5   -0.5   -0.01218   -0.01026
 7.5    6.5   -1.5    0.00691   -0.01075
 7.5    6.5   -2.5    0.00813    0.00386
 7.5    6.5   -3.5   -0.00173    0.00524
 7.5    6.5   -4.5   -0.00286   -0.00057
 7.5    6.5   -5.5    0.00011   -0.00128
 7.5    6.5   -6.5    0.00045   -0.00000
 7.5    6.5   -7.5    0.00001    0.00011
 7.5    5.5    5.5    0.00839   -0.00005
 7.5    5.5    4.5    0.00197    0.01569
 7.5    5.5    3.5   -0.02418    0.00609
 7.5    5.5    2.5   -0.01228   -0.03144
 7.5    5.5    1.5    0.03494   -0.01910
 7.5    5.5    0.5    0.02428    0.03336
 7.5    5.5   -0.5   -0.02734    0.02588
 7.5    5.5   -1.5   -0.02341   -0.01911
 7.5    5.5   -2.5    0.01125   -0.01806
 7.5    5.5   -3.5    0.01184    0.00547
 7.5    5.5   -4.5   -0.00211    0.00654
 7.5    5.5   -5.5   -0.00298   -0.00060
 7.5    5.5   -6.5    0.00011   -0.00107
 7.5    5.5   -7.5    0.00027    0.00000
 7.5    4.5    4.5    0.02971   -0.00011
 7.5    4.5    3.5    0.00591    0.04642
 7.5    4.5    2.5   -0.06136    0.01584
 7.5    4.5    1.5   -0.02777   -0.06942
 7.5    4.5    0.5    0.06763   -0.03778
 7.5    4.5   -0.5    0.04212    0.05676
 7.5    4.5   -1.5   -0.04088    0.03937
 7.5    4.5   -2.5   -0.03114   -0.02505
 7.5    4.5   -3.5    0.01287   -0.02084
 7.5    4.5   -4.5    0.01170    0.00541
 7.5    4.5   -5.5   -0.00179    0.00540
 7.5    4.5   -6.5   -0.00196   -0.00043
 7.5    4.5   -7.5    0.00006   -0.00049
 7.5    3.5    3.5    0.07363   -0.00014
 7.5    3.5    2.5    0.01275    0.09885
 7.5    3.5    1.5   -0.11377    0.02982
 7.5    3.5    0.5   -0.04579   -0.11292
 7.5    3.5   -0.5    0.09680   -0.05468
 7.5    3.5   -1.5    0.05350    0.07148
 7.5    3.5   -2.5   -0.04517    0.04374
 7.5    3.5   -3.5   -0.03002   -0.02416
 7.5    3.5   -4.5    0.01074   -0.01720
 7.5    3.5   -5.5    0.00807    0.00386
 7.5    3.5   -6.5   -0.00106    0.00296
 7.5    3.5   -7.5   -0.00075   -0.00020
 7.5    2.5    2.5    0.13484   -0.00013
 7.5    2.5    1.5    0.02049    0.15777
 7.5    2.5    0.5   -0.15937    0.04207
 7.5    2.5   -0.5   -0.05677   -0.13924
 7.5    2.5   -1.5    0.10503   -0.05953
 7.5    2.5   -2.5    0.05095    0.06807
 7.5    2.5   -3.5   -0.03753    0.03616
 7.5    2.5   -4.5   -0.02125   -0.01736
 7.5    2.5   -5.5    0.00657   -0.01017
 7.5    2.5   -6.5    0.00379    0.00195
 7.5    2.5   -7.5   -0.00040    0.00096
 7.5    1.5    1.5    0.18765   -0.00007
 7.5    1.5    0.5    0.02509    0.19276
 7.5    1.5   -0.5   -0.17141    0.04533
 7.5    1.5   -1.5   -0.05373   -0.13182
 7.5    1.5   -2.5    0.08726   -0.04929
 7.5    1.5   -3.5    0.03661    0.04932
 7.5    1.5   -4.5   -0.02349    0.02222
 7.5    1.5   -5.5   -0.01089   -0.00921
 7.5    1.5   -6.5    0.00285   -0.00414
 7.5    1.5   -7.5    0.00107    0.00061
 7.5    0.5    0.5    0.20130   -0.00004
 7.5    0.5   -0.5    0.02368    0.18206
 7.5    0.5   -1.5   -0.14251    0.03759
 7.5    0.5   -2.5   -0.03896   -0.09615
 7.5    0.5   -3.5    0.05550   -0.03099
 7.5    0.5   -4.5    0.01966    0.02706
 7.5    0.5   -5.5   -0.01091    0.00995
 7.5    0.5   -6.5   -0.00387   -0.00347
 7.5    0.5   -7.5    0.00077   -0.00102
 7.5   -0.5   -0.5    0.16743   -0.00003
 7.5   -0.5   -1.5    0.01727    0.13328
 7.5   -0.5   -2.5   -0.09150    0.02395
 7.5   -0.5   -3.5   -0.02150   -0.05379
 7.5   -0.5   -4.5    0.02676   -0.01460
 7.5   -0.5   -5.5    0.00772    0.01102
 7.5   -0.5   -6.5   -0.00359    0.00309
 7.5   -0.5   -7.5   -0.00083   -0.00082
 7.5   -1.5   -1.5    0.10784   -0.00008
 7.5   -1.5   -2.5    0.00968    0.07526
 7.5   -1.5   -3.5   -0.04501    0.01160
 7.5   -1.5   -4.5   -0.00888   -0.02279
 7.5   -1.5   -5.5    0.00956   -0.00502
 7.5   -1.5   -6.5    0.00210    0.00317
 7.5   -1.5   -7.5   -0.00073    0.00058
 7.5   -2.5   -2.5    0.05339   -0.00008
 7.5   -2.5   -3.5    0.00411    0.03245
 7.5   -2.5   -4.5   -0.01669    0.00419
 7.5   -2.5   -5.5   -0.00266   -0.00711
 7.5   -2.5   -6.5    0.00239   -0.00119
 7.5   -2.5   -7.5    0.00034    0.00056
 7.5   -3.5   -3.5    0.02004   -0.00007
 7.5   -3.5   -4.5    0.00130    0.01046
 7.5   -3.5   -5.5   -0.00451    0.00109
 7.5   -3.5   -6.5   -0.00054   -0.00154
 7.5   -3.5   -7.5    0.00036   -0.00016
 7.5   -4.5   -4.5    0.00554   -0.00005
 7.5   -4.5   -5.5    0.00029    0.00242
 7.5   -4.5   -6.5   -0.00084    0.00019
 7.5   -4.5   -7.5   -0.00006   -0.00020
 7.5   -5.5   -5.5    0.00108   -0.00002
 7.5   -5.5   -6.5    0.00004    0.00038
 7.5   -5.5   -7.5   -0.00009    0.00002
 7.5   -6.5   -6.5    0.00014   -0.00001
 7.5   -6.5   -7.5    0.00001    0.00003
triangle [[ 0.0001+0.j      0.    +0.0004j -0.001 +0.0002j -0.0007-0.0018j  0.0028-0.0014j  0.0023+0.0035j -0.0037+0.0032j -0.0038-0.0034j  0.0026-0.0039j  0.0033+0.0017j -0.0009+0.0025j -0.0016-0.0003j  0.0001-0.0009j  0.0004-0.j      0.    +0.0001j -0.    +0.j    ]
 [ 0.    +0.j      0.0015-0.j      0.0004+0.0035j -0.0065+0.0016j -0.0037-0.0099j  0.0126-0.0067j  0.0097+0.0138j -0.0129+0.0118j -0.0122-0.0103j  0.0069-0.0108j  0.0081+0.0039j -0.0017+0.0052j -0.0029-0.0006j  0.0001-0.0013j  0.0005-0.j      0.    +0.0001j]
 [ 0.    +0.j      0.    +0.j      0.0084-0.0001j  0.002 +0.0157j -0.0242+0.0061j -0.0123-0.0314j  0.0349-0.0191j  0.0243+0.0334j -0.0273+0.0259j -0.0234-0.0191j  0.0113-0.0181j  0.0118+0.0055j -0.0021+0.0065j -0.003 -0.0006j  0.0001-0.0011j  0.0003+0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.0297-0.0001j  0.0059+0.0464j -0.0614+0.0158j -0.0278-0.0694j  0.0676-0.0378j  0.0421+0.0568j -0.0409+0.0394j -0.0311-0.0251j  0.0129-0.0208j  0.0117+0.0054j -0.0018+0.0054j -0.002 -0.0004j  0.0001-0.0005j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0736-0.0001j  0.0128+0.0988j -0.1138+0.0298j -0.0458-0.1129j  0.0968-0.0547j  0.0535+0.0715j -0.0452+0.0437j -0.03  -0.0242j  0.0107-0.0172j  0.0081+0.0039j -0.0011+0.003j  -0.0007-0.0002j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1348-0.0001j  0.0205+0.1578j -0.1594+0.0421j -0.0568-0.1392j  0.105 -0.0595j  0.0509+0.0681j -0.0375+0.0362j -0.0213-0.0174j  0.0066-0.0102j  0.0038+0.0019j -0.0004+0.001j ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1877-0.0001j  0.0251+0.1928j -0.1714+0.0453j -0.0537-0.1318j  0.0873-0.0493j  0.0366+0.0493j -0.0235+0.0222j -0.0109-0.0092j  0.0028-0.0041j  0.0011+0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.2013-0.j      0.0237+0.1821j -0.1425+0.0376j -0.039 -0.0962j  0.0555-0.031j   0.0197+0.0271j -0.0109+0.0099j -0.0039-0.0035j  0.0008-0.001j ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1674-0.j      0.0173+0.1333j -0.0915+0.024j  -0.0215-0.0538j  0.0268-0.0146j  0.0077+0.011j  -0.0036+0.0031j -0.0008-0.0008j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.1078-0.0001j  0.0097+0.0753j -0.045 +0.0116j -0.0089-0.0228j  0.0096-0.005j   0.0021+0.0032j -0.0007+0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0534-0.0001j  0.0041+0.0324j -0.0167+0.0042j -0.0027-0.0071j  0.0024-0.0012j  0.0003+0.0006j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.02  -0.0001j  0.0013+0.0105j -0.0045+0.0011j -0.0005-0.0015j  0.0004-0.0002j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0055-0.j      0.0003+0.0024j -0.0008+0.0002j -0.0001-0.0002j]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0011-0.j      0.    +0.0004j -0.0001+0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.0001-0.j      0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    +0.j      0.    -0.j    ]]
full [[ 0.0001+0.j      0.    +0.0004j -0.001 +0.0002j -0.0007-0.0018j  0.0028-0.0014j  0.0023+0.0035j -0.0037+0.0032j -0.0038-0.0034j  0.0026-0.0039j  0.0033+0.0017j -0.0009+0.0025j -0.0016-0.0003j  0.0001-0.0009j  0.0004-0.j      0.    +0.0001j -0.    +0.j    ]
 [ 0.    -0.0004j  0.0015+0.j      0.0004+0.0035j -0.0065+0.0016j -0.0037-0.0099j  0.0126-0.0067j  0.0097+0.0138j -0.0129+0.0118j -0.0122-0.0103j  0.0069-0.0108j  0.0081+0.0039j -0.0017+0.0052j -0.0029-0.0006j  0.0001-0.0013j  0.0005-0.j      0.    +0.0001j]
 [-0.001 -0.0002j  0.0004-0.0035j  0.0084+0.j      0.002 +0.0157j -0.0242+0.0061j -0.0123-0.0314j  0.0349-0.0191j  0.0243+0.0334j -0.0273+0.0259j -0.0234-0.0191j  0.0113-0.0181j  0.0118+0.0055j -0.0021+0.0065j -0.003 -0.0006j  0.0001-0.0011j  0.0003+0.j    ]
 [-0.0007+0.0018j -0.0065-0.0016j  0.002 -0.0157j  0.0297+0.j      0.0059+0.0464j -0.0614+0.0158j -0.0278-0.0694j  0.0676-0.0378j  0.0421+0.0568j -0.0409+0.0394j -0.0311-0.0251j  0.0129-0.0208j  0.0117+0.0054j -0.0018+0.0054j -0.002 -0.0004j  0.0001-0.0005j]
 [ 0.0028+0.0014j -0.0037+0.0099j -0.0242-0.0061j  0.0059-0.0464j  0.0736+0.j      0.0128+0.0988j -0.1138+0.0298j -0.0458-0.1129j  0.0968-0.0547j  0.0535+0.0715j -0.0452+0.0437j -0.03  -0.0242j  0.0107-0.0172j  0.0081+0.0039j -0.0011+0.003j  -0.0007-0.0002j]
 [ 0.0023-0.0035j  0.0126+0.0067j -0.0123+0.0314j -0.0614-0.0158j  0.0128-0.0988j  0.1348+0.j      0.0205+0.1578j -0.1594+0.0421j -0.0568-0.1392j  0.105 -0.0595j  0.0509+0.0681j -0.0375+0.0362j -0.0213-0.0174j  0.0066-0.0102j  0.0038+0.0019j -0.0004+0.001j ]
 [-0.0037-0.0032j  0.0097-0.0138j  0.0349+0.0191j -0.0278+0.0694j -0.1138-0.0298j  0.0205-0.1578j  0.1877+0.j      0.0251+0.1928j -0.1714+0.0453j -0.0537-0.1318j  0.0873-0.0493j  0.0366+0.0493j -0.0235+0.0222j -0.0109-0.0092j  0.0028-0.0041j  0.0011+0.0006j]
 [-0.0038+0.0034j -0.0129-0.0118j  0.0243-0.0334j  0.0676+0.0378j -0.0458+0.1129j -0.1594-0.0421j  0.0251-0.1928j  0.2013+0.j      0.0237+0.1821j -0.1425+0.0376j -0.039 -0.0962j  0.0555-0.031j   0.0197+0.0271j -0.0109+0.0099j -0.0039-0.0035j  0.0008-0.001j ]
 [ 0.0026+0.0039j -0.0122+0.0103j -0.0273-0.0259j  0.0421-0.0568j  0.0968+0.0547j -0.0568+0.1392j -0.1714-0.0453j  0.0237-0.1821j  0.1674+0.j      0.0173+0.1333j -0.0915+0.024j  -0.0215-0.0538j  0.0268-0.0146j  0.0077+0.011j  -0.0036+0.0031j -0.0008-0.0008j]
 [ 0.0033-0.0017j  0.0069+0.0108j -0.0234+0.0191j -0.0409-0.0394j  0.0535-0.0715j  0.105 +0.0595j -0.0537+0.1318j -0.1425-0.0376j  0.0173-0.1333j  0.1078+0.j      0.0097+0.0753j -0.045 +0.0116j -0.0089-0.0228j  0.0096-0.005j   0.0021+0.0032j -0.0007+0.0006j]
 [-0.0009-0.0025j  0.0081-0.0039j  0.0113+0.0181j -0.0311+0.0251j -0.0452-0.0437j  0.0509-0.0681j  0.0873+0.0493j -0.039 +0.0962j -0.0915-0.024j   0.0097-0.0753j  0.0534+0.j      0.0041+0.0324j -0.0167+0.0042j -0.0027-0.0071j  0.0024-0.0012j  0.0003+0.0006j]
 [-0.0016+0.0003j -0.0017-0.0052j  0.0118-0.0055j  0.0129+0.0208j -0.03  +0.0242j -0.0375-0.0362j  0.0366-0.0493j  0.0555+0.031j  -0.0215+0.0538j -0.045 -0.0116j  0.0041-0.0324j  0.02  +0.j      0.0013+0.0105j -0.0045+0.0011j -0.0005-0.0015j  0.0004-0.0002j]
 [ 0.0001+0.0009j -0.0029+0.0006j -0.0021-0.0065j  0.0117-0.0054j  0.0107+0.0172j -0.0213+0.0174j -0.0235-0.0222j  0.0197-0.0271j  0.0268+0.0146j -0.0089+0.0228j -0.0167-0.0042j  0.0013-0.0105j  0.0055+0.j      0.0003+0.0024j -0.0008+0.0002j -0.0001-0.0002j]
 [ 0.0004+0.j      0.0001+0.0013j -0.003 +0.0006j -0.0018-0.0054j  0.0081-0.0039j  0.0066+0.0102j -0.0109+0.0092j -0.0109-0.0099j  0.0077-0.011j   0.0096+0.005j  -0.0027+0.0071j -0.0045-0.0011j  0.0003-0.0024j  0.0011+0.j      0.    +0.0004j -0.0001+0.j    ]
 [ 0.    -0.0001j  0.0005+0.j      0.0001+0.0011j -0.002 +0.0004j -0.0011-0.003j   0.0038-0.0019j  0.0028+0.0041j -0.0039+0.0035j -0.0036-0.0031j  0.0021-0.0032j  0.0024+0.0012j -0.0005+0.0015j -0.0008-0.0002j  0.    -0.0004j  0.0001+0.j      0.    +0.j    ]
 [-0.    -0.j      0.    -0.0001j  0.0003-0.j      0.0001+0.0005j -0.0007+0.0002j -0.0004-0.001j   0.0011-0.0006j  0.0008+0.001j  -0.0008+0.0008j -0.0007-0.0006j  0.0003-0.0006j  0.0004+0.0002j -0.0001+0.0002j -0.0001-0.j      0.    -0.j      0.    +0.j    ]]
Sum of c^2 0.9925762243152352
Thu Apr 17 13:25:58 PDT 2025
